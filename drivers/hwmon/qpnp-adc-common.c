/* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

#define pr_fmt(fmt) "%s: " fmt, __func__

#include <linux/kernel.h>
#include <linux/of.h>
#include <linux/err.h>
#include <linux/init.h>
#include <linux/slab.h>
#include <linux/delay.h>
#include <linux/mutex.h>
#include <linux/types.h>
#include <linux/hwmon.h>
#include <linux/module.h>
#include <linux/debugfs.h>
#include <linux/spmi.h>
#include <linux/of_irq.h>
#include <linux/interrupt.h>
#include <linux/completion.h>
#include <linux/qpnp/qpnp-adc.h>
#include <linux/platform_device.h>
/* Min ADC code represets 0V */
#define QPNP_VADC_MIN_ADC_CODE			0x6000
/* Max ADC code represents full-scale range of 1.8V */
#define QPNP_VADC_MAX_ADC_CODE			0xA800
#define KELVINMIL_DEGMIL	273160

/* Units for temperature below (on x axis) is in 0.1DegC as
   required by the battery driver. Note the resolution used
   here to compute the table was done for DegC to milli-volts.
   In consideration to limit the size of the table for the given
   temperature range below, the result is linearly interpolated
   and provided to the battery driver in the units desired for
   their framework which is 0.1DegC. True resolution of 0.1DegC
   will result in the below table size to increase by 10 times */
static const struct qpnp_vadc_map_pt adcmap_btm_threshold[] = {
//[Feature]-Add-BEGIN by TCTSZ.Del qcom for battery NTC baili.ouyang.sz@tcl.com,  2015/10/12, for PR716604
#if defined (JRD_PROJECT_POP45C)||defined (JRD_PROJECT_POP455C)
//BYD NTC
{ -400 , 1686 },
{ -390 , 1680 },
{ -380 , 1674 },
{ -370 , 1668 },
{ -360 , 1661 },
{ -350 , 1654 },
{ -340 , 1647 },
{ -330 , 1640 },
{ -320 , 1632 },
{ -310 , 1625 },
{ -300 , 1617 },
{ -290 , 1608 },
{ -280 , 1600 },
{ -270 , 1591 },
{ -260 , 1582 },
{ -250 , 1573 },
{ -240 , 1563 },
{ -230 , 1553 },
{ -220 , 1543 },
{ -210 , 1532 },
{ -200 , 1522 },
{ -190 , 1511 },
{ -180 , 1500 },
{ -170 , 1488 },
{ -160 , 1476 },
{ -150 , 1465 },
{ -140 , 1452 },
{ -130 , 1440 },
{ -120 , 1428 },
{ -110 , 1415 },
{ -100 , 1402 },
{ -90 , 1389 },
{ -80 , 1375 },
{ -70 , 1362 },
{ -60 , 1348 },
{ -50 , 1334 },
{ -40 , 1320 },
{ -30 , 1306 },
{ -20 , 1292 },
{ -10 , 1278 },
{ 0 , 1263 },
{ 10 , 1249 },
{ 20 , 1234 },
{ 30 , 1219 },
{ 40 , 1205 },
{ 50 , 1190 },
{ 60 , 1176 },
{ 70 , 1161 },
{ 80 , 1146 },
{ 90 , 1132 },
{ 100 , 1117 },
{ 110 , 1103 },
{ 120 , 1088 },
{ 130 , 1074 },
{ 140 , 1059 },
{ 150 , 1045 },
{ 160 , 1031 },
{ 170 , 1017 },
{ 180 , 1003 },
{ 190 , 989 },
{ 200 , 976 },
{ 210 , 962 },
{ 220 , 949 },
{ 230 , 936 },
{ 240 , 923 },
{ 250 , 910 },
{ 260 , 898 },
{ 270 , 885 },
{ 280 , 873 },
{ 290 , 861 },
{ 300 , 849 },
{ 310 , 838 },
{ 320 , 826 },
{ 330 , 815 },
{ 340 , 804 },
{ 350 , 793 },
{ 360 , 783 },
{ 370 , 772 },
{ 380 , 762 },
{ 390 , 752 },
{ 400 , 742 },
{ 410 , 733 },
{ 420 , 724 },
{ 430 , 714 },
{ 440 , 706 },
{ 450 , 697 },
{ 460 , 688 },
{ 470 , 680 },
{ 480 , 672 },
{ 490 , 664 },
{ 500 , 656 },
{ 510 , 649 },
{ 520 , 641 },
{ 530 , 634 },
{ 540 , 627 },
{ 550 , 620 },
{ 560 , 614 },
{ 570 , 607 },
{ 580 , 601 },
{ 590 , 595 },
{ 600 , 589 },
{ 610 , 583 },
{ 620 , 577 },
{ 630 , 572 },
{ 640 , 566 },
{ 650 , 561 },
{ 660 , 556 },
{ 670 , 551 },
{ 680 , 546 },
{ 690 , 542 },
{ 700 , 537 },
{ 710 , 533 },
{ 720 , 528 },
{ 730 , 524 },
{ 740 , 520 },
{ 750 , 516 },
{ 760 , 512 },
{ 770 , 508 },
{ 780 , 505 },
{ 790 , 501 },
{ 800 , 498 },
{ 810 , 494 },
{ 820 , 491 },
{ 830 , 488 },
{ 840 , 485 },
{ 850 , 482 },
{ 860 , 479 },
{ 870 , 476 },
{ 880 , 473 },
{ 890 , 471 },
{ 900 , 468 },
{ 910 , 465 },
{ 920 , 463 },
{ 930 , 461 },
{ 940 , 458 },
{ 950 , 456 },
{ 960 , 454 },
{ 970 , 452 },
{ 980 , 450 },
{ 990 , 447 },
{ 1000 , 445 },
{ 1010 , 444 },
{ 1020 , 442 },
{ 1030 , 440 },
{ 1040 , 438 },
{ 1050 , 436 },
{ 1060 , 435 },
{ 1070 , 433 },
{ 1080 , 431 },
{ 1090 , 430 },
{ 1100 , 428 },
{ 1110 , 427 },
{ 1120 , 425 },
{ 1130 , 424 },
{ 1140 , 423 },
{ 1150 , 421 },
{ 1160 , 420 },
{ 1170 , 419 },
{ 1180 , 418 },
{ 1190 , 416 },
{ 1200 , 415 },
{ 1210 , 414 },
{ 1220 , 413 },
{ 1230 , 412 },
{ 1240 , 411 },
{ 1250 , 410 }
//TCTSZ.Del qcom for batt-id-tmp baili.ouyang.sz@tcl.com, 2016/4/22, for Task1163258
#elif defined (JRD_PROJECT_POP45)
{ -400 , 1694 },
{ -390 , 1689 },
{ -380 , 1683 },
{ -370 , 1676 },
{ -360 , 1670 },
{ -350 , 1663 },
{ -340 , 1656 },
{ -330 , 1649 },
{ -320 , 1641 },
{ -310 , 1634 },
{ -300 , 1626 },
{ -290 , 1617 },
{ -280 , 1609 },
{ -270 , 1600 },
{ -260 , 1591 },
{ -250 , 1581 },
{ -240 , 1572 },
{ -230 , 1562 },
{ -220 , 1551 },
{ -210 , 1541 },
{ -200 , 1530 },
{ -190 , 1519 },
{ -180 , 1508 },
{ -170 , 1496 },
{ -160 , 1484 },
{ -150 , 1472 },
{ -140 , 1460 },
{ -130 , 1447 },
{ -120 , 1434 },
{ -110 , 1421 },
{ -100 , 1408 },
{ -90 , 1395 },
{ -80 , 1381 },
{ -70 , 1368 },
{ -60 , 1354 },
{ -50 , 1340 },
{ -40 , 1325 },
{ -30 , 1311 },
{ -20 , 1297 },
{ -10 , 1282 },
{ 0 , 1267 },
{ 10 , 1253 },
{ 20 , 1238 },
{ 30 , 1223 },
{ 40 , 1208 },
{ 50 , 1193 },
{ 60 , 1178 },
{ 70 , 1164 },
{ 80 , 1149 },
{ 90 , 1134 },
{ 100 , 1119 },
{ 110 , 1104 },
{ 120 , 1090 },
{ 130 , 1075 },
{ 140 , 1061 },
{ 150 , 1046 },
{ 160 , 1032 },
{ 170 , 1018 },
{ 180 , 1004 },
{ 190 , 990 },
{ 200 , 976 },
{ 210 , 963 },
{ 220 , 949 },
{ 230 , 936 },
{ 240 , 923 },
{ 250 , 910 },
{ 260 , 898 },
{ 270 , 885 },
{ 280 , 873 },
{ 290 , 861 },
{ 300 , 849 },
{ 310 , 838 },
{ 320 , 826 },
{ 330 , 815 },
{ 340 , 804 },
{ 350 , 793 },
{ 360 , 783 },
{ 370 , 772 },
{ 380 , 762 },
{ 390 , 752 },
{ 400 , 743 },
{ 410 , 733 },
{ 420 , 724 },
{ 430 , 715 },
{ 440 , 706 },
{ 450 , 697 },
{ 460 , 689 },
{ 470 , 680 },
{ 480 , 672 },
{ 490 , 664 },
{ 500 , 657 },
{ 510 , 649 },
{ 520 , 642 },
{ 530 , 635 },
{ 540 , 628 },
{ 550 , 621 },
{ 560 , 614 },
{ 570 , 608 },
{ 580 , 601 },
{ 590 , 595 },
{ 600 , 589 },
{ 610 , 583 },
{ 620 , 578 },
{ 630 , 572 },
{ 640 , 567 },
{ 650 , 562 },
{ 660 , 557 },
{ 670 , 552 },
{ 680 , 547 },
{ 690 , 542 },
{ 700 , 537 },
{ 710 , 533 },
{ 720 , 529 },
{ 730 , 524 },
{ 740 , 520 },
{ 750 , 516 },
{ 760 , 512 },
{ 770 , 509 },
{ 780 , 505 },
{ 790 , 501 },
{ 800 , 498 },
{ 810 , 495 },
{ 820 , 491 },
{ 830 , 488 },
{ 840 , 485 },
{ 850 , 482 },
{ 860 , 479 },
{ 870 , 476 },
{ 880 , 473 },
{ 890 , 470 },
{ 900 , 468 },
{ 910 , 465 },
{ 920 , 462 },
{ 930 , 460 },
{ 940 , 457 },
{ 950 , 455 },
{ 960 , 453 },
{ 970 , 450 },
{ 980 , 448 },
{ 990 , 446 },
{ 1000 , 444 },
{ 1010 , 442 },
{ 1020 , 440 },
{ 1030 , 438 },
{ 1040 , 436 },
{ 1050 , 434 },
{ 1060 , 433 },
{ 1070 , 431 },
{ 1080 , 429 },
{ 1090 , 428 },
{ 1100 , 426 },
{ 1110 , 425 },
{ 1120 , 423 },
{ 1130 , 422 },
{ 1140 , 420 },
{ 1150 , 419 },
{ 1160 , 417 },
{ 1170 , 416 },
{ 1180 , 415 },
{ 1190 , 414 },
{ 1200 , 413 },
{ 1210 , 411 },
{ 1220 , 410 },
{ 1230 , 409 },
{ 1240 , 408 },
{ 1250 , 407 }
//[Feature]-Add-BEGIN by TCTSZ.Del qcom for get temp baili.ouyang.sz@tcl.com, 2016/1/15, for Task523741
#elif defined (JRD_PROJECT_PIXI4554G)
{ -400 , 1694 },
{ -390 , 1689 },
{ -380 , 1683 },
{ -370 , 1676 },
{ -360 , 1670 },
{ -350 , 1663 },
{ -340 , 1656 },
{ -330 , 1649 },
{ -320 , 1641 },
{ -310 , 1634 },
{ -300 , 1626 },
{ -290 , 1617 },
{ -280 , 1609 },
{ -270 , 1600 },
{ -260 , 1591 },
{ -250 , 1581 },
{ -240 , 1572 },
{ -230 , 1562 },
{ -220 , 1551 },
{ -210 , 1541 },
{ -200 , 1530 },
{ -190 , 1519 },
{ -180 , 1508 },
{ -170 , 1496 },
{ -160 , 1484 },
{ -150 , 1472 },
{ -140 , 1460 },
{ -130 , 1447 },
{ -120 , 1434 },
{ -110 , 1421 },
{ -100 , 1408 },
{ -90 , 1395 },
{ -80 , 1381 },
{ -70 , 1368 },
{ -60 , 1354 },
{ -50 , 1340 },
{ -40 , 1325 },
{ -30 , 1311 },
{ -20 , 1297 },
{ -10 , 1282 },
{ 0 , 1267 },
{ 10 , 1253 },
{ 20 , 1238 },
{ 30 , 1223 },
{ 40 , 1208 },
{ 50 , 1193 },
{ 60 , 1178 },
{ 70 , 1164 },
{ 80 , 1149 },
{ 90 , 1134 },
{ 100 , 1119 },
{ 110 , 1104 },
{ 120 , 1090 },
{ 130 , 1075 },
{ 140 , 1061 },
{ 150 , 1046 },
{ 160 , 1032 },
{ 170 , 1018 },
{ 180 , 1004 },
{ 190 , 990 },
{ 200 , 976 },
{ 210 , 963 },
{ 220 , 949 },
{ 230 , 936 },
{ 240 , 923 },
{ 250 , 910 },
{ 260 , 898 },
{ 270 , 885 },
{ 280 , 873 },
{ 290 , 861 },
{ 300 , 849 },
{ 310 , 838 },
{ 320 , 826 },
{ 330 , 815 },
{ 340 , 804 },
{ 350 , 793 },
{ 360 , 783 },
{ 370 , 772 },
{ 380 , 762 },
{ 390 , 752 },
{ 400 , 743 },
{ 410 , 733 },
{ 420 , 724 },
{ 430 , 715 },
{ 440 , 706 },
{ 450 , 697 },
{ 460 , 689 },
{ 470 , 680 },
{ 480 , 672 },
{ 490 , 664 },
{ 500 , 657 },
{ 510 , 649 },
{ 520 , 642 },
{ 530 , 635 },
{ 540 , 628 },
{ 550 , 621 },
{ 560 , 614 },
{ 570 , 608 },
{ 580 , 601 },
{ 590 , 595 },
{ 600 , 589 },
{ 610 , 583 },
{ 620 , 578 },
{ 630 , 572 },
{ 640 , 567 },
{ 650 , 562 },
{ 660 , 557 },
{ 670 , 552 },
{ 680 , 547 },
{ 690 , 542 },
{ 700 , 537 },
{ 710 , 533 },
{ 720 , 529 },
{ 730 , 524 },
{ 740 , 520 },
{ 750 , 516 },
{ 760 , 512 },
{ 770 , 509 },
{ 780 , 505 },
{ 790 , 501 },
{ 800 , 498 },
{ 810 , 495 },
{ 820 , 491 },
{ 830 , 488 },
{ 840 , 485 },
{ 850 , 482 },
{ 860 , 479 },
{ 870 , 476 },
{ 880 , 473 },
{ 890 , 470 },
{ 900 , 468 },
{ 910 , 465 },
{ 920 , 462 },
{ 930 , 460 },
{ 940 , 457 },
{ 950 , 455 },
{ 960 , 453 },
{ 970 , 450 },
{ 980 , 448 },
{ 990 , 446 },
{ 1000 , 444 },
{ 1010 , 442 },
{ 1020 , 440 },
{ 1030 , 438 },
{ 1040 , 436 },
{ 1050 , 434 },
{ 1060 , 433 },
{ 1070 , 431 },
{ 1080 , 429 },
{ 1090 , 428 },
{ 1100 , 426 },
{ 1110 , 425 },
{ 1120 , 423 },
{ 1130 , 422 },
{ 1140 , 420 },
{ 1150 , 419 },
{ 1160 , 417 },
{ 1170 , 416 },
{ 1180 , 415 },
{ 1190 , 414 },
{ 1200 , 413 },
{ 1210 , 411 },
{ 1220 , 410 },
{ 1230 , 409 },
{ 1240 , 408 },
{ 1250 , 407 }
//[Feature]-Add-END by TCTSZ.baili.ouyang.sz@tcl.com, 2016/1/15, for Task523741

#elif defined (JRD_PROJECT_PIXI3454GSPR)
//SCUD NTC
	{-400,	1677},
	{-390,	1670},
	{-380,	1664},
	{-370,	1657},
	{-360,	1650},
	{-350,	1643},
	{-340,	1636},
	{-330,	1629},
	{-320,	1621},
	{-310,	1613},
	{-300,	1605},
	{-290,	1597},
	{-280,	1588},
	{-270,	1579},
	{-260,	1570},
	{-250,	1561},
	{-240,	1552},
	{-230,	1542},
	{-220,	1532},
	{-210,	1522},
	{-200,	1511},
	{-190,	1501},
	{-180,	1490},
	{-170,	1479},
	{-160,	1468},
	{-150,	1456},
	{-140,	1445},
	{-130,	1433},
	{-120,	1421},
	{-110,	1408},
	{-100, 	1396},
	{-90,	1383},
	{-80,	1370},
	{-70,	1357},
	{-60,	1344},
	{-50,	1330},
	{-40,	1317},
	{-30,	1303},
	{-20,	1289},
	{-10,	1275},
	{0,	1261},
	{10,	1247},
	{20,	1232},
	{30,	1218},
	{40,	1203},
	{50,	1189},
	{60,	1174},
	{70,	1160},
	{80,	1145},
	{90,	1131},
	{100,	1116},
	{110,	1102},
	{120,	1087},
	{130,	1073},
	{140,	1059},
	{150,	1045},
	{160,	1031},
	{170,	1017},
	{180,	1003},
	{190,	989},
	{200,	976},
	{210,	962},
	{220,	949},
	{230,	936},
	{240,	923},
	{250,	910},
	{260,	898},
	{270,	885},
	{280,	873},
	{290,	861},
	{300,	849},
	{310,	838},
	{320,	826},
	{330,	815},
	{340,	804},
	{350,	793},
	{360,	783},
	{370,	773},
	{380,	762},
	{390,	752},
	{400,	743},
	{410,	733},
	{420,	724},
	{430,	715},
	{440,	706},
	{450,	697},
	{460,	689},
	{470,	681},
	{480,	673},
	{490,	665},
	{500,	657},
	{510,	649},
	{520,	642},
	{530,	635},
	{540,	628},
	{550,	621},
	{560,	615},
	{570,	608},
	{580,	602},
	{590,	596},
	{600,	590},
	{610,	584},
	{620,	578},
	{630,	573},
	{640,	568},
	{650,	562},
	{660,	557},
	{670,	552},
	{680,	547},
	{690,	543},
	{700,	538},
	{710,	534},
	{720,	530},
	{730,	525},
	{740,	521},
	{750,	517},
	{760,	513},
	{770,	510},
	{780,	506},
	{790,	502},
	{800,	499},
	{810,	496},
	{820,	492},
	{830,	489},
	{840,	486},
	{850,	483},
	{860,	480},
	{870,	477},
	{880,	475},
	{890,	472},
	{900,	469},
	{910,	467},
	{920,	464},
	{930,	462},
	{940,	460},
	{950,	457},
	{960,	455},
	{970,	453},
	{980,	451},
	{990,	449},
	{1000,	447},
	{1010,	445},
	{1020,	443},
	{1030,	441},
	{1040,	439},
	{1050,	438},
	{1060,	436},
	{1070,	434},
	{1080,	433},
	{1090,	431},
	{1100,	430},
	{1110,	428},
	{1120,	427},
	{1130,	425},
	{1140,	424},
	{1150,	423},
	{1160,	421},
	{1170,	420},
	{1180,	419},
	{1190,	418},
	{1200,	417},
	{1210,	415},
	{1220,	414},
	{1230,	413},
	{1240,	412},
	{1250,	411}

//[Feature]-Add-BEGIN by TCTSZ. pm8909 charging for ntc map kaiying.zhang@tcl.com, 2015/12/8, for PR716612  
#elif defined(JRD_PROJECT_PIXI445SPR)
//BYD ID
	{-400,	1690}, 
	{-390,	1684}, 
	{-380,	1678}, 
	{-370,	1671}, 
	{-360,	1665}, 
	{-350,	1658}, 
	{-340,	1651}, 
	{-330,	1643}, 
	{-320,	1636}, 
	{-310,	1628}, 
	{-300,	1620}, 
	{-290,	1611}, 
	{-280,	1602}, 
	{-270,	1593}, 
	{-260,	1584}, 
	{-250,	1575}, 
	{-240,	1565}, 
	{-230,	1555}, 
	{-220,	1545}, 
	{-210,	1534}, 
	{-200,	1523}, 
	{-190,	1512}, 
	{-180,	1501}, 
	{-170,	1489}, 
	{-160,	1477}, 
	{-150,	1465}, 
	{-140,	1453}, 
	{-130,	1441}, 
	{-120,	1428}, 
	{-110,	1415}, 
	{-100,	1402}, 
	{-90,	1389}, 
	{-80,	1375}, 
	{-70,	1362}, 
	{-60,	1348}, 
	{-50,	1334}, 
	{-40,	1320}, 
	{-30,	1305}, 
	{-20,	1291}, 
	{-10,	1277}, 
	{0, 	1262}, 
	{10,	1248}, 
	{20,	1233}, 
	{30,	1219}, 
	{40,	1204}, 
	{50,	1189}, 
	{60,	1175}, 
	{70,	1160}, 
	{80,	1145}, 
	{90,	1131}, 
	{100,	1116}, 
	{110,	1102}, 
	{120,	1087}, 
	{130,	1073}, 
	{140,	1059}, 
	{150,	1045}, 
	{160,	1030}, 
	{170,	1017}, 
	{180,	1003}, 
	{190,	989}, 
	{200,	975}, 
	{210,	962}, 
	{220,	949}, 
	{230,	936}, 
	{240,	923}, 
	{250,	910}, 
	{260,	898}, 
	{270,	885}, 
	{280,	873}, 
	{290,	861}, 
	{300,	849}, 
	{310,	838}, 
	{320,	826}, 
	{330,	815}, 
	{340,	804}, 
	{350,	793}, 
	{360,	783}, 
	{370,	773}, 
	{380,	762}, 
	{390,	753}, 
	{400,	743}, 
	{410,	733}, 
	{420,	724}, 
	{430,	715}, 
	{440,	706}, 
	{450,	697}, 
	{460,	689}, 
	{470,	680}, 
	{480,	672}, 
	{490,	664}, 
	{500,	656}, 
	{510,	649}, 
	{520,	641}, 
	{530,	634}, 
	{540,	627}, 
	{550,	620}, 
	{560,	614}, 
	{570,	607}, 
	{580,	601}, 
	{590,	594}, 
	{600,	588}, 
	{610,	583}, 
	{620,	577}, 
	{630,	572}, 
	{640,	566}, 
	{650,	561}, 
	{660,	556}, 
	{670,	551}, 
	{680,	546}, 
	{690,	542}, 
	{700,	537}, 
	{710,	533}, 
	{720,	528}, 
	{730,	524}, 
	{740,	520}, 
	{750,	516}, 
	{760,	512}, 
	{770,	508}, 
	{780,	505}, 
	{790,	501}, 
	{800,	498}, 
	{810,	494}, 
	{820,	491}, 
	{830,	488}, 
	{840,	485}, 
	{850,	482}, 
	{860,	479}, 
	{870,	476}, 
	{880,	473}, 
	{890,	471}, 
	{900,	468}, 
	{910,	465}, 
	{920,	463}, 
	{930,	461}, 
	{940,	458}, 
	{950,	456}, 
	{960,	454}, 
	{970,	452}, 
	{980,	449}, 
	{990,	447}, 
	{1000,	445}, 
	{1010,	443}, 
	{1020,	442}, 
	{1030,	440}, 
	{1040,	438}, 
	{1050,	436}, 
	{1060,	435}, 
	{1070,	433}, 
	{1080,	431}, 
	{1090,	430}, 
	{1100,	428}, 
	{1110,	427}, 
	{1120,	425}, 
	{1130,	424}, 
	{1140,	423}, 
	{1150,	421}, 
	{1160,	420}, 
	{1170,	419}, 
	{1180,	417}, 
	{1190,	416}, 
	{1200,	415}, 
	{1210,	414}, 
	{1220,	413}, 
	{1230,	412}, 
	{1240,	411}, 
	{1250,	410}  
#elif defined(JRD_PROJECT_PIXI445CRICKET)
	{-300,	1605},
	{-200,	1511},
	{-100,	1396},
	{0,	1261},
	{10,	1247},
	{20,	1232},
	{30,	1218},
	{40,	1203},
	{50,	1189},
	{60,	1174},
	{70,	1160},
	{80,	1145},
	{90,	1131},
	{100,	1116},
	{110,	1102},
	{120,	1087},
	{130,	1073},
	{140,	1059},
	{150,	1045},
	{160,	1031},
	{170,	1017},
	{180,	1003},
	{190,	989},
	{200,	976},
	{210,	962},
	{220,	949},
	{230,	936},
	{240,	923},
	{250,	910},
	{260,	898},
	{270,	885},
	{280,	873},
	{290,	861},
	{300,	849},
	{310,	838},
	{320,	826},
	{330,	815},
	{340,	804},
	{350,	793},
	{360,	783},
	{370,	773},
	{380,	762},
	{390,	752},
	{400,	743},
	{410,	733},
	{420,	724},
	{430,	715},
	{440,	706},
	{450,	697},
	{460,	689},
	{470,	681},
	{480,	673},
	{490,	665},
	{500,	657},
	{510,	649},
	{520,	642},
	{530,	635},
	{540,	628},
	{550,	621},
	{560,	615},
	{570,	608},
	{580,	602},
	{590,	596},
	{600,	590},
	{610,	584},
	{620,	578},
	{630,	573},
	{640,	568},
	{650,	562},
	{660,	557},
	{670,	552},
	{680,	547},
	{690,	543},
	{700,	538},
	{710,	534},
	{720,	530},
	{730,	525},
	{740,	521},
	{750,	517},
	{760,	513},
	{770,	510},
	{780,	506},
	{790,	502}
#elif defined (JRD_PROJECT_PIXI464G) || defined (JRD_PROJECT_PIXI464GCRICKET)
//PIXI464G 1st battery JN TLp025DC
	{-400,1708},
	{-390,1702},
	{-380,1697},
	{-370,1691},
	{-360,1685},
	{-350,1678},
	{-340,1672},
	{-330,1665},
	{-320,1658},
	{-310,1650},
	{-300,1642},
	{-290,1634},
	{-280,1626},
	{-270,1617},
	{-260,1609},
	{-250,1599},
	{-240,1590},
	{-230,1580},
	{-220,1570},
	{-210,1559},
	{-200,1548},
	{-190,1537},
	{-180,1526},
	{-170,1514},
	{-160,1502},
	{-150,1490},
	{-140,1477},
	{-130,1464},
	{-120,1451},
	{-110,1437},
	{-100,1423},
	{-90,1409},
	{-80,1395},
	{-70,1381},
	{-60,1366},
	{-50,1351},
	{-40,1336},
	{-30,1320},
	{-20,1304},
	{-10,1289},
	{0,1273},
	{10,1257},
	{20,1240},
	{30,1224},
	{40,1207},
	{50,1191},
	{60,1174},
	{70,1157},
	{80,1141},
	{90,1124},
	{100,1107},
	{110,1090},
	{120,1073},
	{130,1056},
	{140,1040},
	{150,1023},
	{160,1006},
	{170,990},
	{180,973},
	{190,957},
	{200,940},
	{210,924},
	{220,908},
	{230,892},
	{240,876},
	{250,861},
	{260,845},
	{270,830},
	{280,815},
	{290,800},
	{300,786},
	{310,771},
	{320,757},
	{330,743},
	{340,729},
	{350,716},
	{360,702},
	{370,689},
	{380,676},
	{390,664},
	{400,651},
	{410,639},
	{420,627},
	{430,615},
	{440,604},
	{450,592},
	{460,581},
	{470,571},
	{480,560},
	{490,550},
	{500,540},
	{510,530},
	{520,520},
	{530,511},
	{540,502},
	{550,493},
	{560,484},
	{570,475},
	{580,467},
	{590,459},
	{600,451},
	{610,443},
	{620,435},
	{630,428},
	{640,421},
	{650,414},
	{660,407},
	{670,400},
	{680,394},
	{690,387},
	{700,381},
	{710,375},
	{720,369},
	{730,363},
	{740,358},
	{750,352},
	{760,347},
	{770,342},
	{780,337},
	{790,332},
	{800,327},
	{810,323},
	{820,318},
	{830,314},
	{840,309},
	{850,305},
	{860,301},
	{870,297},
	{880,294},
	{890,290},
	{900,286},
	{910,283},
	{920,279},
	{930,276},
	{940,273},
	{950,269},
	{960,266},
	{970,263},
	{980,260},
	{990,257},
	{1000,255},
	{1010,252},
	{1020,249},
	{1030,247},
	{1040,244},
	{1050,242},
	{1060,239},
	{1070,237},
	{1080,235},
	{1090,233},
	{1100,230},
	{1110,228},
	{1120,226},
	{1130,224},
	{1140,222},
	{1150,221},
	{1160,219},
	{1170,217},
	{1180,215},
	{1190,213},
	{1200,212},
	{1210,210},
	{1220,209},
	{1230,207},
	{1240,206},
	{1250,204}
#else
	{-300,	1642},
	{-200,	1544},
	{-100,	1414},
	{0,	1260},
	{10,	1244},
	{20,	1228},
	{30,	1212},
	{40,	1195},
	{50,	1179},
	{60,	1162},
	{70,	1146},
	{80,	1129},
	{90,	1113},
	{100,	1097},
	{110,	1080},
	{120,	1064},
	{130,	1048},
	{140,	1032},
	{150,	1016},
	{160,	1000},
	{170,	985},
	{180,	969},
	{190,	954},
	{200,	939},
	{210,	924},
	{220,	909},
	{230,	894},
	{240,	880},
	{250,	866},
	{260,	852},
	{270,	838},
	{280,	824},
	{290,	811},
	{300,	798},
	{310,	785},
	{320,	773},
	{330,	760},
	{340,	748},
	{350,	736},
	{360,	725},
	{370,	713},
	{380,	702},
	{390,	691},
	{400,	681},
	{410,	670},
	{420,	660},
	{430,	650},
	{440,	640},
	{450,	631},
	{460,	622},
	{470,	613},
	{480,	604},
	{490,	595},
	{500,	587},
	{510,	579},
	{520,	571},
	{530,	563},
	{540,	556},
	{550,	548},
	{560,	541},
	{570,	534},
	{580,	527},
	{590,	521},
	{600,	514},
	{610,	508},
	{620,	502},
	{630,	496},
	{640,	490},
	{650,	485},
	{660,	281},
	{670,	274},
	{680,	267},
	{690,	260},
	{700,	254},
	{710,	247},
	{720,	241},
	{730,	235},
	{740,	229},
	{750,	224},
	{760,	218},
	{770,	213},
	{780,	208},
	{790,	203}
#endif
//[Feature]-Add-END by TCTSZ.baili.ouyang.sz@tcl.com, 2015/6/24, for PR369037
};
//[Feature]-Add-BEGIN by TCTSZ.Del qcom for batt-id-tmp baili.ouyang.sz@tcl.com, 2016/4/22, for Task1163258
#if defined (JRD_PROJECT_POP45)
int ret_battery_id = 1;
static const struct qpnp_vadc_map_pt adcmap_btm_threshold_jiade[] = {
//jiade ntc
{ -400 , 1693 },
{ -390 , 1688 },
{ -380 , 1682 },
{ -370 , 1676 },
{ -360 , 1669 },
{ -350 , 1663 },
{ -340 , 1656 },
{ -330 , 1649 },
{ -320 , 1641 },
{ -310 , 1634 },
{ -300 , 1626 },
{ -290 , 1617 },
{ -280 , 1609 },
{ -270 , 1600 },
{ -260 , 1591 },
{ -250 , 1582 },
{ -240 , 1572 },
{ -230 , 1562 },
{ -220 , 1552 },
{ -210 , 1542 },
{ -200 , 1531 },
{ -190 , 1520 },
{ -180 , 1509 },
{ -170 , 1497 },
{ -160 , 1485 },
{ -150 , 1473 },
{ -140 , 1461 },
{ -130 , 1449 },
{ -120 , 1436 },
{ -110 , 1423 },
{ -100 , 1410 },
{ -90 , 1396 },
{ -80 , 1383 },
{ -70 , 1369 },
{ -60 , 1355 },
{ -50 , 1341 },
{ -40 , 1327 },
{ -30 , 1313 },
{ -20 , 1298 },
{ -10 , 1284 },
{ 0 , 1269 },
{ 10 , 1254 },
{ 20 , 1239 },
{ 30 , 1225 },
{ 40 , 1210 },
{ 50 , 1195 },
{ 60 , 1180 },
{ 70 , 1165 },
{ 80 , 1150 },
{ 90 , 1135 },
{ 100 , 1120 },
{ 110 , 1105 },
{ 120 , 1091 },
{ 130 , 1076 },
{ 140 , 1062 },
{ 150 , 1047 },
{ 160 , 1033 },
{ 170 , 1018 },
{ 180 , 1004 },
{ 190 , 990 },
{ 200 , 977 },
{ 210 , 963 },
{ 220 , 950 },
{ 230 , 936 },
{ 240 , 923 },
{ 250 , 910 },
{ 260 , 898 },
{ 270 , 885 },
{ 280 , 873 },
{ 290 , 861 },
{ 300 , 849 },
{ 310 , 837 },
{ 320 , 825 },
{ 330 , 814 },
{ 340 , 803 },
{ 350 , 792 },
{ 360 , 781 },
{ 370 , 771 },
{ 380 , 761 },
{ 390 , 751 },
{ 400 , 741 },
{ 410 , 731 },
{ 420 , 722 },
{ 430 , 713 },
{ 440 , 704 },
{ 450 , 695 },
{ 460 , 687 },
{ 470 , 678 },
{ 480 , 670 },
{ 490 , 662 },
{ 500 , 655 },
{ 510 , 647 },
{ 520 , 640 },
{ 530 , 633 },
{ 540 , 626 },
{ 550 , 619 },
{ 560 , 612 },
{ 570 , 606 },
{ 580 , 599 },
{ 590 , 593 },
{ 600 , 587 },
{ 610 , 582 },
{ 620 , 576 },
{ 630 , 570 },
{ 640 , 565 },
{ 650 , 560 },
{ 660 , 555 },
{ 670 , 550 },
{ 680 , 545 },
{ 690 , 540 },
{ 700 , 536 },
{ 710 , 532 },
{ 720 , 527 },
{ 730 , 523 },
{ 740 , 519 },
{ 750 , 515 },
{ 760 , 511 },
{ 770 , 507 },
{ 780 , 504 },
{ 790 , 500 },
{ 800 , 497 },
{ 810 , 494 },
{ 820 , 490 },
{ 830 , 487 },
{ 840 , 484 },
{ 850 , 481 },
{ 860 , 478 },
{ 870 , 475 },
{ 880 , 473 },
{ 890 , 470 },
{ 900 , 468 },
{ 910 , 465 },
{ 920 , 462 },
{ 930 , 460 },
{ 940 , 458 },
{ 950 , 456 },
{ 960 , 453 },
{ 970 , 451 },
{ 980 , 449 },
{ 990 , 447 },
{ 1000 , 445 },
{ 1010 , 443 },
{ 1020 , 441 },
{ 1030 , 440 },
{ 1040 , 438 },
{ 1050 , 436 },
{ 1060 , 435 },
{ 1070 , 433 },
{ 1080 , 431 },
{ 1090 , 430 },
{ 1100 , 428 },
{ 1110 , 427 },
{ 1120 , 425 },
{ 1130 , 424 },
{ 1140 , 423 },
{ 1150 , 421 },
{ 1160 , 420 },
{ 1170 , 419 },
{ 1180 , 418 },
{ 1190 , 417 },
{ 1200 , 415 },
{ 1210 , 414 },
{ 1220 , 413 },
{ 1230 , 412 },
{ 1240 , 411 },
{ 1250 , 410 }
};
static const struct qpnp_vadc_map_pt adcmap_btm_threshold_byd[] = {
//BYD ntc
{ -400 , 1686 },
{ -390 , 1680 },
{ -380 , 1674 },
{ -370 , 1668 },
{ -360 , 1661 },
{ -350 , 1654 },
{ -340 , 1647 },
{ -330 , 1640 },
{ -320 , 1632 },
{ -310 , 1625 },
{ -300 , 1617 },
{ -290 , 1608 },
{ -280 , 1600 },
{ -270 , 1591 },
{ -260 , 1582 },
{ -250 , 1573 },
{ -240 , 1563 },
{ -230 , 1553 },
{ -220 , 1543 },
{ -210 , 1532 },
{ -200 , 1522 },
{ -190 , 1511 },
{ -180 , 1500 },
{ -170 , 1488 },
{ -160 , 1476 },
{ -150 , 1465 },
{ -140 , 1452 },
{ -130 , 1440 },
{ -120 , 1428 },
{ -110 , 1415 },
{ -100 , 1402 },
{ -90 , 1389 },
{ -80 , 1375 },
{ -70 , 1362 },
{ -60 , 1348 },
{ -50 , 1334 },
{ -40 , 1320 },
{ -30 , 1306 },
{ -20 , 1292 },
{ -10 , 1278 },
{ 0 , 1263 },
{ 10 , 1249 },
{ 20 , 1234 },
{ 30 , 1219 },
{ 40 , 1205 },
{ 50 , 1190 },
{ 60 , 1176 },
{ 70 , 1161 },
{ 80 , 1146 },
{ 90 , 1132 },
{ 100 , 1117 },
{ 110 , 1103 },
{ 120 , 1088 },
{ 130 , 1074 },
{ 140 , 1059 },
{ 150 , 1045 },
{ 160 , 1031 },
{ 170 , 1017 },
{ 180 , 1003 },
{ 190 , 989 },
{ 200 , 976 },
{ 210 , 962 },
{ 220 , 949 },
{ 230 , 936 },
{ 240 , 923 },
{ 250 , 910 },
{ 260 , 898 },
{ 270 , 885 },
{ 280 , 873 },
{ 290 , 861 },
{ 300 , 849 },
{ 310 , 838 },
{ 320 , 826 },
{ 330 , 815 },
{ 340 , 804 },
{ 350 , 793 },
{ 360 , 783 },
{ 370 , 772 },
{ 380 , 762 },
{ 390 , 752 },
{ 400 , 742 },
{ 410 , 733 },
{ 420 , 724 },
{ 430 , 714 },
{ 440 , 706 },
{ 450 , 697 },
{ 460 , 688 },
{ 470 , 680 },
{ 480 , 672 },
{ 490 , 664 },
{ 500 , 656 },
{ 510 , 649 },
{ 520 , 641 },
{ 530 , 634 },
{ 540 , 627 },
{ 550 , 620 },
{ 560 , 614 },
{ 570 , 607 },
{ 580 , 601 },
{ 590 , 595 },
{ 600 , 589 },
{ 610 , 583 },
{ 620 , 577 },
{ 630 , 572 },
{ 640 , 566 },
{ 650 , 561 },
{ 660 , 556 },
{ 670 , 551 },
{ 680 , 546 },
{ 690 , 542 },
{ 700 , 537 },
{ 710 , 533 },
{ 720 , 528 },
{ 730 , 524 },
{ 740 , 520 },
{ 750 , 516 },
{ 760 , 512 },
{ 770 , 508 },
{ 780 , 505 },
{ 790 , 501 },
{ 800 , 498 },
{ 810 , 494 },
{ 820 , 491 },
{ 830 , 488 },
{ 840 , 485 },
{ 850 , 482 },
{ 860 , 479 },
{ 870 , 476 },
{ 880 , 473 },
{ 890 , 471 },
{ 900 , 468 },
{ 910 , 465 },
{ 920 , 463 },
{ 930 , 461 },
{ 940 , 458 },
{ 950 , 456 },
{ 960 , 454 },
{ 970 , 452 },
{ 980 , 450 },
{ 990 , 447 },
{ 1000 , 445 },
{ 1010 , 444 },
{ 1020 , 442 },
{ 1030 , 440 },
{ 1040 , 438 },
{ 1050 , 436 },
{ 1060 , 435 },
{ 1070 , 433 },
{ 1080 , 431 },
{ 1090 , 430 },
{ 1100 , 428 },
{ 1110 , 427 },
{ 1120 , 425 },
{ 1130 , 424 },
{ 1140 , 423 },
{ 1150 , 421 },
{ 1160 , 420 },
{ 1170 , 419 },
{ 1180 , 418 },
{ 1190 , 416 },
{ 1200 , 415 },
{ 1210 , 414 },
{ 1220 , 413 },
{ 1230 , 412 },
{ 1240 , 411 },
{ 1250 , 410 }
};
#endif
//[Feature]-Add-END by TCTSZ.baili.ouyang.sz@tcl.com, 2016/4/22, for Task1163258
//add by junfeng.zhou for make  two battery's ntc adcmap compatibility begin
#if defined (JRD_PROJECT_POP45C)||defined (JRD_PROJECT_POP455C)
int ret_battery_id = 0;
static const struct qpnp_vadc_map_pt adcmap_btm_threshold_scud[] = {
	//SCUD NTC
	{-400,	1677},
	{-390,	1670},
	{-380,	1664},
	{-370,	1657},
	{-360,	1650},
	{-350,	1643},
	{-340,	1636},
	{-330,	1629},
	{-320,	1621},
	{-310,	1613},
	{-300,	1605},
	{-290,	1597},
	{-280,	1588},
	{-270,	1579},
	{-260,	1570},
	{-250,	1561},
	{-240,	1552},
	{-230,	1542},
	{-220,	1532},
	{-210,	1522},
	{-200,	1511},
	{-190,	1501},
	{-180,	1490},
	{-170,	1479},
	{-160,	1468},
	{-150,	1456},
	{-140,	1445},
	{-130,	1433},
	{-120,	1421},
	{-110,	1408},
	{-100, 	1396},
	{-90,	1383},
	{-80,	1370},
	{-70,	1357},
	{-60,	1344},
	{-50,	1330},
	{-40,	1317},
	{-30,	1303},
	{-20,	1289},
	{-10,	1275},
	{0,	1261},
	{10,	1247},
	{20,	1232},
	{30,	1218},
	{40,	1203},
	{50,	1189},
	{60,	1174},
	{70,	1160},
	{80,	1145},
	{90,	1131},
	{100,	1116},
	{110,	1102},
	{120,	1087},
	{130,	1073},
	{140,	1059},
	{150,	1045},
	{160,	1031},
	{170,	1017},
	{180,	1003},
	{190,	989},
	{200,	976},
	{210,	962},
	{220,	949},
	{230,	936},
	{240,	923},
	{250,	910},
	{260,	898},
	{270,	885},
	{280,	873},
	{290,	861},
	{300,	849},
	{310,	838},
	{320,	826},
	{330,	815},
	{340,	804},
	{350,	793},
	{360,	783},
	{370,	773},
	{380,	762},
	{390,	752},
	{400,	743},
	{410,	733},
	{420,	724},
	{430,	715},
	{440,	706},
	{450,	697},
	{460,	689},
	{470,	681},
	{480,	673},
	{490,	665},
	{500,	657},
	{510,	649},
	{520,	642},
	{530,	635},
	{540,	628},
	{550,	621},
	{560,	615},
	{570,	608},
	{580,	602},
	{590,	596},
	{600,	590},
	{610,	584},
	{620,	578},
	{630,	573},
	{640,	568},
	{650,	562},
	{660,	557},
	{670,	552},
	{680,	547},
	{690,	543},
	{700,	538},
	{710,	534},
	{720,	530},
	{730,	525},
	{740,	521},
	{750,	517},
	{760,	513},
	{770,	510},
	{780,	506},
	{790,	502},
	{800,	499},
	{810,	496},
	{820,	492},
	{830,	489},
	{840,	486},
	{850,	483},
	{860,	480},
	{870,	477},
	{880,	475},
	{890,	472},
	{900,	469},
	{910,	467},
	{920,	464},
	{930,	462},
	{940,	460},
	{950,	457},
	{960,	455},
	{970,	453},
	{980,	451},
	{990,	449},
	{1000,	447},
	{1010,	445},
	{1020,	443},
	{1030,	441},
	{1040,	439},
	{1050,	438},
	{1060,	436},
	{1070,	434},
	{1080,	433},
	{1090,	431},
	{1100,	430},
	{1110,	428},
	{1120,	427},
	{1130,	425},
	{1140,	424},
	{1150,	423},
	{1160,	421},
	{1170,	420},
	{1180,	419},
	{1190,	418},
	{1200,	417},
	{1210,	415},
	{1220,	414},
	{1230,	413},
	{1240,	412},
	{1250,	411}
};
#endif
//add by junfeng.zhou end
//[Feature]-Add-BEGIN by huichen@tcl.com, 2016/02/19, for alm 1561781
#if defined (JRD_PROJECT_PIXI464G) || defined (JRD_PROJECT_PIXI464GCRICKET)
int PIXI464G_ret_battery_id = 0;
static const struct qpnp_vadc_map_pt adcmap_btm_threshold_scud[] = {
//pixi474g 2nd BATTERY scud TLp025D2
	{-400,1685},   
	{-390,1679}, 
	{-380,1673}, 
	{-370,1667}, 
	{-360,1660}, 
	{-350,1653}, 
	{-340,1646}, 
	{-330,1639}, 
	{-320,1632}, 
	{-310,1624}, 
	{-300,1616}, 
	{-290,1608}, 
	{-280,1600}, 
	{-270,1591}, 
	{-260,1582}, 
	{-250,1573}, 
	{-240,1564}, 
	{-230,1554}, 
	{-220,1544}, 
	{-210,1534}, 
	{-200,1524}, 
	{-190,1513}, 
	{-180,1502}, 
	{-170,1491}, 
	{-160,1480}, 
	{-150,1468}, 
	{-140,1456}, 
	{-130,1444}, 
	{-120,1431}, 
	{-110,1419}, 
	{-100,1406}, 
	{-90,1392 },
	{-80,1379}, 
	{-70,1365}, 
	{-60,1351}, 
	{-50,1337}, 
	{-40,1323}, 
	{-30,1308}, 
	{-20,1293}, 
	{-10,1278}, 
	{0,1263}, 
	{10,1247}, 
	{20,1231}, 
	{30,1216}, 
	{40,1200}, 
	{50,1184}, 
	{60,1167}, 
	{70,1151}, 
	{80,1135}, 
	{90,1119},
	{100,1102}, 
	{110,1086}, 
	{120,1069}, 
	{130,1053}, 
	{140,1036}, 
	{150,1020}, 
	{160,1004}, 
	{170,988},  
	{180,971},  
	{190,955},  
	{200,939},  
	{210,923},  
	{220,907},  
	{230,892},  
	{240,876},  
	{250,861},  
	{260,846},  
	{270,831},  
	{280,816},  
	{290,801},  
	{300,786},  
	{310,772},  
	{320,758},  
	{330,744},  
	{340,730},  
	{350,717},  
	{360,703},  
	{370,690},  
	{380,677},  
	{390,665},  
	{400,652},  
	{410,640},  
	{420,628},  
	{430,617},  
	{440,605},  
	{450,594},  
	{460,583},  
	{470,572},  
	{480,562},  
	{490,551},  
	{500,541},  
	{510,531},  
	{520,522},  
	{530,512},  
	{540,503},  
	{550,494},  
	{560,485},  
	{570,476},  
	{580,468},  
	{590,460},  
	{600,452},  
	{610,444},  
	{620,436},  
	{630,429},  
	{640,422},  
	{650,414},  
	{660,408},  
	{670,401},  
	{680,394},  
	{690,388},  
	{700,382},  
	{710,375},  
	{720,369},  
	{730,364},  
	{740,358},  
	{750,353},  
	{760,347},  
	{770,342},  
	{780,337},  
	{790,332},  
	{800,327},  
	{810,323},  
	{820,318},  
	{830,314},  
	{840,310},  
	{850,305},  
	{860,301},  
	{870,297},  
	{880,294},  
	{890,290},  
	{900,286},  
	{910,283},  
	{920,279},  
	{930,276},  
	{940,273},  
	{950,269},  
	{960,266},  
	{970,263},  
	{980,260},  
	{990,257},  
	{1000,255},  
	{1010,252},  
	{1020,249},  
	{1030,247},  
	{1040,244},  
	{1050,242},  
	{1060,240},  
	{1070,237},  
	{1080,235},  
	{1090,233},  
	{1100,231},  
	{1110,229},  
	{1120,227},  
	{1130,225},  
	{1140,223},  
	{1150,221},  
	{1160,219},  
	{1170,217},  
	{1180,216},  
	{1190,214},  
	{1200,212},  
	{1210,211},  
	{1220,209},  
	{1230,208},  
	{1240,206},  
	{1250,205}
};
#endif
//[Feature]-Add-END by huichen@tcl.com

static const struct qpnp_vadc_map_pt adcmap_qrd_btm_threshold[] = {
	{-200,	1540},
	{-180,	1517},
	{-160,	1492},
	{-140,	1467},
	{-120,	1440},
	{-100,	1412},
	{-80,	1383},
	{-60,	1353},
	{-40,	1323},
	{-20,	1292},
	{0,	1260},
	{20,	1228},
	{40,	1196},
	{60,	1163},
	{80,	1131},
	{100,	1098},
	{120,	1066},
	{140,	1034},
	{160,	1002},
	{180,	971},
	{200,	941},
	{220,	911},
	{240,	882},
	{260,	854},
	{280,	826},
	{300,	800},
	{320,	774},
	{340,	749},
	{360,	726},
	{380,	703},
	{400,	681},
	{420,	660},
	{440,	640},
	{460,	621},
	{480,	602},
	{500,	585},
	{520,	568},
	{540,	552},
	{560,	537},
	{580,	523},
	{600,	510},
	{620,	497},
	{640,	485},
	{660,	473},
	{680,	462},
	{700,	452},
	{720,	442},
	{740,	433},
	{760,	424},
	{780,	416},
	{800,	408},
};

static const struct qpnp_vadc_map_pt adcmap_qrd_skuaa_btm_threshold[] = {
	{-200,	1476},
	{-180,	1450},
	{-160,	1422},
	{-140,	1394},
	{-120,	1365},
	{-100,	1336},
	{-80,	1306},
	{-60,	1276},
	{-40,	1246},
	{-20,	1216},
	{0,	1185},
	{20,	1155},
	{40,	1126},
	{60,	1096},
	{80,	1068},
	{100,	1040},
	{120,	1012},
	{140,	986},
	{160,	960},
	{180,	935},
	{200,	911},
	{220,	888},
	{240,	866},
	{260,	844},
	{280,	824},
	{300,	805},
	{320,	786},
	{340,	769},
	{360,	752},
	{380,	737},
	{400,	722},
	{420,	707},
	{440,	694},
	{460,	681},
	{480,	669},
	{500,	658},
	{520,	648},
	{540,	637},
	{560,	628},
	{580,	619},
	{600,	611},
	{620,	603},
	{640,	595},
	{660,	588},
	{680,	582},
	{700,	575},
	{720,	569},
	{740,	564},
	{760,	559},
	{780,	554},
	{800,	549},
};

static const struct qpnp_vadc_map_pt adcmap_qrd_skug_btm_threshold[] = {
	{-200,	1338},
	{-180,	1307},
	{-160,	1276},
	{-140,	1244},
	{-120,	1213},
	{-100,	1182},
	{-80,	1151},
	{-60,	1121},
	{-40,	1092},
	{-20,	1063},
	{0,	1035},
	{20,	1008},
	{40,	982},
	{60,	957},
	{80,	933},
	{100,	910},
	{120,	889},
	{140,	868},
	{160,	848},
	{180,	830},
	{200,	812},
	{220,	795},
	{240,	780},
	{260,	765},
	{280,	751},
	{300,	738},
	{320,	726},
	{340,	714},
	{360,	704},
	{380,	694},
	{400,	684},
	{420,	675},
	{440,	667},
	{460,	659},
	{480,	652},
	{500,	645},
	{520,	639},
	{540,	633},
	{560,	627},
	{580,	622},
	{600,	617},
	{620,	613},
	{640,	608},
	{660,	604},
	{680,	600},
	{700,	597},
	{720,	593},
	{740,	590},
	{760,	587},
	{780,	585},
	{800,	582},
};

static const struct qpnp_vadc_map_pt adcmap_qrd_skuh_btm_threshold[] = {
	{-200,	1531},
	{-180,	1508},
	{-160,	1483},
	{-140,	1458},
	{-120,	1432},
	{-100,	1404},
	{-80,	1377},
	{-60,	1348},
	{-40,	1319},
	{-20,	1290},
	{0,	1260},
	{20,	1230},
	{40,	1200},
	{60,	1171},
	{80,	1141},
	{100,	1112},
	{120,	1083},
	{140,	1055},
	{160,	1027},
	{180,	1000},
	{200,	973},
	{220,	948},
	{240,	923},
	{260,	899},
	{280,	876},
	{300,	854},
	{320,	832},
	{340,	812},
	{360,	792},
	{380,	774},
	{400,	756},
	{420,	739},
	{440,	723},
	{460,	707},
	{480,	692},
	{500,	679},
	{520,	665},
	{540,	653},
	{560,	641},
	{580,	630},
	{600,	619},
	{620,	609},
	{640,	600},
	{660,	591},
	{680,	583},
	{700,	575},
	{720,	567},
	{740,	560},
	{760,	553},
	{780,	547},
	{800,	541},
	{820,	535},
	{840,	530},
	{860,	524},
	{880,	520},
};

static const struct qpnp_vadc_map_pt adcmap_qrd_skuc_btm_threshold[] = {
	{-200,	1539},
	{-180,	1515},
	{-160,	1491},
	{-140,	1465},
	{-120,	1438},
	{-100,	1410},
	{-80,	1381},
	{-60,	1352},
	{-40,	1322},
	{-20,	1291},
	{0,	1260},
	{20,	1229},
	{40,	1197},
	{60,	1166},
	{80,	1134},
	{100,	1103},
	{120,	1072},
	{140,	1042},
	{160,	1012},
	{180,	982},
	{200,	954},
	{220,	926},
	{240,	899},
	{260,	873},
	{280,	847},
	{300,	823},
	{320,	800},
	{340,	777},
	{360,	756},
	{380,	735},
	{400,	715},
	{420,	696},
	{440,	679},
	{460,	662},
	{480,	645},
	{500,	630},
	{520,	615},
	{540,	602},
	{560,	588},
	{580,	576},
	{600,	564},
	{620,	553},
	{640,	543},
	{660,	533},
	{680,	523},
	{700,	515},
	{720,	506},
	{740,	498},
	{760,	491},
	{780,	484},
	{800,	477},
};

static const struct qpnp_vadc_map_pt adcmap_qrd_skue_btm_threshold[] = {
	{-200,	1385},
	{-180,	1353},
	{-160,	1320},
	{-140,	1287},
	{-120,	1253},
	{-100,	1218},
	{-80,	1184},
	{-60,	1149},
	{-40,	1115},
	{-20,	1080},
	{0,	1046},
	{20,	1013},
	{40,	980},
	{60,	948},
	{80,	917},
	{100,	887},
	{120,	858},
	{140,	830},
	{160,	803},
	{180,	777},
	{200,	752},
	{220,	729},
	{240,	706},
	{260,	685},
	{280,	664},
	{300,	645},
	{320,	626},
	{340,	609},
	{360,	593},
	{380,	577},
	{400,	563},
	{420,	549},
	{440,	536},
	{460,	524},
	{480,	512},
	{500,	501},
	{520,	491},
	{540,	481},
	{560,	472},
	{580,	464},
	{600,	456},
	{620,	448},
	{640,	441},
	{660,	435},
	{680,	428},
	{700,	423},
	{720,	417},
	{740,	412},
	{760,	407},
	{780,	402},
	{800,	398},
};

static const struct qpnp_vadc_map_pt adcmap_qrd_skul_btm_threshold[] = {
	{-200,	1515},
	{-180,	1492},
	{-160,	1467},
	{-140,	1441},
	{-120,	1413},
	{-100,	1386},
	{-80,	1357},
	{-60,	1327},
	{-40,	1296},
	{-20,	1264},
	{0,	1232},
	{20,	1200},
	{40,	1167},
	{60,	1134},
	{80,	1100},
	{100,	1050},
	{120,	1034},
	{140,	1000},
	{160,	967},
	{180,	935},
	{200,	903},
	{220,	871},
	{240,	840},
	{260,	810},
	{280,	780},
	{300,	751},
	{320,	723},
	{340,	696},
	{360,	670},
	{380,	645},
	{400,	620},
	{420,	597},
	{440,	574},
	{460,	552},
	{480,	531},
	{500,	512},
	{520,	492},
	{540,	474},
	{560,	457},
	{580,	440},
	{600,	425},
	{620,	410},
	{640,	396},
	{660,	383},
	{680,	370},
	{700,	358},
	{720,	347},
	{740,	336},
	{760,	326},
	{780,	311},
	{800,	307},
};

/* Voltage to temperature */
static const struct qpnp_vadc_map_pt adcmap_100k_104ef_104fb[] = {
	{1758,	-40},
	{1742,	-35},
	{1719,	-30},
	{1691,	-25},
	{1654,	-20},
	{1608,	-15},
	{1551,	-10},
	{1483,	-5},
	{1404,	0},
	{1315,	5},
	{1218,	10},
	{1114,	15},
	{1007,	20},
	{900,	25},
	{795,	30},
	{696,	35},
	{605,	40},
	{522,	45},
	{448,	50},
	{383,	55},
	{327,	60},
	{278,	65},
	{237,	70},
	{202,	75},
	{172,	80},
	{146,	85},
	{125,	90},
	{107,	95},
	{92,	100},
	{79,	105},
	{68,	110},
	{59,	115},
	{51,	120},
	{44,	125}
};

/* Voltage to temperature */
static const struct qpnp_vadc_map_pt adcmap_150k_104ef_104fb[] = {
	{1738,	-40},
	{1714,	-35},
	{1682,	-30},
	{1641,	-25},
	{1589,	-20},
	{1526,	-15},
	{1451,	-10},
	{1363,	-5},
	{1266,	0},
	{1159,	5},
	{1048,	10},
	{936,	15},
	{825,	20},
	{720,	25},
	{622,	30},
	{533,	35},
	{454,	40},
	{385,	45},
	{326,	50},
	{275,	55},
	{232,	60},
	{195,	65},
	{165,	70},
	{139,	75},
	{118,	80},
	{100,	85},
	{85,	90},
	{73,	95},
	{62,	100},
	{53,	105},
	{46,	110},
	{40,	115},
	{34,	120},
	{30,	125}
};

static const struct qpnp_vadc_map_pt adcmap_smb_batt_therm[] = {
	{-300,	1625},
	{-200,	1515},
	{-100,	1368},
	{0,	1192},
	{10,	1173},
	{20,	1154},
	{30,	1135},
	{40,	1116},
	{50,	1097},
	{60,	1078},
	{70,	1059},
	{80,	1040},
	{90,	1020},
	{100,	1001},
	{110,	982},
	{120,	963},
	{130,	944},
	{140,	925},
	{150,	907},
	{160,	888},
	{170,	870},
	{180,	851},
	{190,	833},
	{200,	815},
	{210,	797},
	{220,	780},
	{230,	762},
	{240,	745},
	{250,	728},
	{260,	711},
	{270,	695},
	{280,	679},
	{290,	663},
	{300,	647},
	{310,	632},
	{320,	616},
	{330,	602},
	{340,	587},
	{350,	573},
	{360,	559},
	{370,	545},
	{380,	531},
	{390,	518},
	{400,	505},
	{410,	492},
	{420,	480},
	{430,	465},
	{440,	456},
	{450,	445},
	{460,	433},
	{470,	422},
	{480,	412},
	{490,	401},
	{500,	391},
	{510,	381},
	{520,	371},
	{530,	362},
	{540,	352},
	{550,	343},
	{560,	335},
	{570,	326},
	{580,	318},
	{590,	309},
	{600,	302},
	{610,	294},
	{620,	286},
	{630,	279},
	{640,	272},
	{650,	265},
	{660,	258},
	{670,	252},
	{680,	245},
	{690,	239},
	{700,	233},
	{710,	227},
	{720,	221},
	{730,	216},
	{740,	211},
	{750,	205},
	{760,	200},
	{770,	195},
	{780,	190},
	{790,	186}
};

/* Voltage to temperature */
static const struct qpnp_vadc_map_pt adcmap_ncp03wf683[] = {
	{1742,	-40},
	{1718,	-35},
	{1687,	-30},
	{1647,	-25},
	{1596,	-20},
	{1534,	-15},
	{1459,	-10},
	{1372,	-5},
	{1275,	0},
	{1169,	5},
	{1058,	10},
	{945,	15},
	{834,	20},
	{729,	25},
	{630,	30},
	{541,	35},
	{461,	40},
	{392,	45},
	{332,	50},
	{280,	55},
	{236,	60},
	{199,	65},
	{169,	70},
	{142,	75},
	{121,	80},
	{102,	85},
	{87,	90},
	{74,	95},
	{64,	100},
	{55,	105},
	{47,	110},
	{40,	115},
	{35,	120},
	{30,	125}
};
static int32_t qpnp_adc_map_voltage_temp(const struct qpnp_vadc_map_pt *pts,
		uint32_t tablesize, int32_t input, int64_t *output)
{
	bool descending = 1;
	uint32_t i = 0;

	if (pts == NULL)
		return -EINVAL;

	/* Check if table is descending or ascending */
	if (tablesize > 1) {
		if (pts[0].x < pts[1].x)
			descending = 0;
	}

	while (i < tablesize) {
		if ((descending == 1) && (pts[i].x < input)) {
			/* table entry is less than measured
				value and table is descending, stop */
			break;
		} else if ((descending == 0) &&
				(pts[i].x > input)) {
			/* table entry is greater than measured
				value and table is ascending, stop */
			break;
		} else {
			i++;
		}
	}

	if (i == 0)
		*output = pts[0].y;
	else if (i == tablesize)
		*output = pts[tablesize-1].y;
	else {
		/* result is between search_index and search_index-1 */
		/* interpolate linearly */
		*output = (((int32_t) ((pts[i].y - pts[i-1].y)*
			(input - pts[i-1].x))/
			(pts[i].x - pts[i-1].x))+
			pts[i-1].y);
	}

	return 0;
}

static int32_t qpnp_adc_map_temp_voltage(const struct qpnp_vadc_map_pt *pts,
		uint32_t tablesize, int32_t input, int64_t *output)
{
	bool descending = 1;
	uint32_t i = 0;

	if (pts == NULL)
		return -EINVAL;

	/* Check if table is descending or ascending */
	if (tablesize > 1) {
		if (pts[0].y < pts[1].y)
			descending = 0;
	}

	while (i < tablesize) {
		if ((descending == 1) && (pts[i].y < input)) {
			/* table entry is less than measured
				value and table is descending, stop */
			break;
		} else if ((descending == 0) && (pts[i].y > input)) {
			/* table entry is greater than measured
				value and table is ascending, stop */
			break;
		} else {
			i++;
		}
	}

	if (i == 0) {
		*output = pts[0].x;
	} else if (i == tablesize) {
		*output = pts[tablesize-1].x;
	} else {
		/* result is between search_index and search_index-1 */
		/* interpolate linearly */
		*output = (((int32_t) ((pts[i].x - pts[i-1].x)*
			(input - pts[i-1].y))/
			(pts[i].y - pts[i-1].y))+
			pts[i-1].x);
	}

	return 0;
}

static int64_t qpnp_adc_scale_ratiometric_calib(int32_t adc_code,
		const struct qpnp_adc_properties *adc_properties,
		const struct qpnp_vadc_chan_properties *chan_properties)
{
	int64_t adc_voltage = 0;
	bool negative_offset = 0;

	if (!chan_properties || !chan_properties->offset_gain_numerator ||
		!chan_properties->offset_gain_denominator || !adc_properties)
		return -EINVAL;

	adc_voltage = (adc_code -
		chan_properties->adc_graph[CALIB_RATIOMETRIC].adc_gnd)
		* adc_properties->adc_vdd_reference;
	if (adc_voltage < 0) {
		negative_offset = 1;
		adc_voltage = -adc_voltage;
	}
	do_div(adc_voltage,
		chan_properties->adc_graph[CALIB_RATIOMETRIC].dy);
	if (negative_offset)
		adc_voltage = -adc_voltage;

	return adc_voltage;
}

int32_t qpnp_adc_scale_pmic_therm(struct qpnp_vadc_chip *vadc,
		int32_t adc_code,
		const struct qpnp_adc_properties *adc_properties,
		const struct qpnp_vadc_chan_properties *chan_properties,
		struct qpnp_vadc_result *adc_chan_result)
{
	int64_t pmic_voltage = 0;
	bool negative_offset = 0;

	if (!chan_properties || !chan_properties->offset_gain_numerator ||
		!chan_properties->offset_gain_denominator || !adc_properties
		|| !adc_chan_result
		|| !chan_properties->adc_graph[CALIB_ABSOLUTE].dy)
		return -EINVAL;

	pmic_voltage = (adc_code -
		chan_properties->adc_graph[CALIB_ABSOLUTE].adc_gnd)
		* chan_properties->adc_graph[CALIB_ABSOLUTE].dx;
	if (pmic_voltage < 0) {
		negative_offset = 1;
		pmic_voltage = -pmic_voltage;
	}
	do_div(pmic_voltage,
		chan_properties->adc_graph[CALIB_ABSOLUTE].dy);
	if (negative_offset)
		pmic_voltage = -pmic_voltage;
	pmic_voltage += chan_properties->adc_graph[CALIB_ABSOLUTE].dx;

	if (pmic_voltage > 0) {
		/* 2mV/K */
		adc_chan_result->measurement = pmic_voltage*
			chan_properties->offset_gain_denominator;

		do_div(adc_chan_result->measurement,
			chan_properties->offset_gain_numerator * 2);
	} else {
		adc_chan_result->measurement = 0;
	}
	/* Change to .001 deg C */
	adc_chan_result->measurement -= KELVINMIL_DEGMIL;
	adc_chan_result->physical = (int32_t)adc_chan_result->measurement;

	return 0;
}
EXPORT_SYMBOL(qpnp_adc_scale_pmic_therm);

int32_t qpnp_adc_scale_millidegc_pmic_voltage_thr(struct qpnp_vadc_chip *chip,
		struct qpnp_adc_tm_btm_param *param,
		uint32_t *low_threshold, uint32_t *high_threshold)
{
	struct qpnp_vadc_linear_graph btm_param;
	int64_t low_output = 0, high_output = 0;
	int rc = 0, sign = 0;

	rc = qpnp_get_vadc_gain_and_offset(chip, &btm_param, CALIB_ABSOLUTE);
	if (rc < 0) {
		pr_err("Could not acquire gain and offset\n");
		return rc;
	}

	/* Convert to Kelvin and account for voltage to be written as 2mV/K */
	low_output = (param->low_temp + KELVINMIL_DEGMIL) * 2;
	/* Convert to voltage threshold */
	low_output = (low_output - QPNP_ADC_625_UV) * btm_param.dy;
	if (low_output < 0) {
		sign = 1;
		low_output = -low_output;
	}
	do_div(low_output, QPNP_ADC_625_UV);
	if (sign)
		low_output = -low_output;
	low_output += btm_param.adc_gnd;

	sign = 0;
	/* Convert to Kelvin and account for voltage to be written as 2mV/K */
	high_output = (param->high_temp + KELVINMIL_DEGMIL) * 2;
	/* Convert to voltage threshold */
	high_output = (high_output - QPNP_ADC_625_UV) * btm_param.dy;
	if (high_output < 0) {
		sign = 1;
		high_output = -high_output;
	}
	do_div(high_output, QPNP_ADC_625_UV);
	if (sign)
		high_output = -high_output;
	high_output += btm_param.adc_gnd;

	*low_threshold = (uint32_t) low_output;
	*high_threshold = (uint32_t) high_output;
	pr_debug("high_temp:%d, low_temp:%d\n", param->high_temp,
				param->low_temp);
	pr_debug("adc_code_high:%x, adc_code_low:%x\n", *high_threshold,
				*low_threshold);

	return 0;
}
EXPORT_SYMBOL(qpnp_adc_scale_millidegc_pmic_voltage_thr);

/* Scales the ADC code to degC using the mapping
 * table for the XO thermistor.
 */
int32_t qpnp_adc_tdkntcg_therm(struct qpnp_vadc_chip *chip,
		int32_t adc_code,
		const struct qpnp_adc_properties *adc_properties,
		const struct qpnp_vadc_chan_properties *chan_properties,
		struct qpnp_vadc_result *adc_chan_result)
{
	int64_t xo_thm = 0;

	if (!chan_properties || !chan_properties->offset_gain_numerator ||
		!chan_properties->offset_gain_denominator || !adc_properties
		|| !adc_chan_result)
		return -EINVAL;

	xo_thm = qpnp_adc_scale_ratiometric_calib(adc_code,
			adc_properties, chan_properties);

	qpnp_adc_map_voltage_temp(adcmap_100k_104ef_104fb,
		ARRAY_SIZE(adcmap_100k_104ef_104fb),
		xo_thm, &adc_chan_result->physical);

	return 0;
}
EXPORT_SYMBOL(qpnp_adc_tdkntcg_therm);

int32_t qpnp_adc_scale_batt_therm(struct qpnp_vadc_chip *chip,
		int32_t adc_code,
		const struct qpnp_adc_properties *adc_properties,
		const struct qpnp_vadc_chan_properties *chan_properties,
		struct qpnp_vadc_result *adc_chan_result)
{
	int64_t bat_voltage = 0;
	
	bat_voltage = qpnp_adc_scale_ratiometric_calib(adc_code,
			adc_properties, chan_properties);

	adc_chan_result->measurement = bat_voltage;
//add by junfeng.zhou for make  two battery's ntc adcmap compatibility begin
#if defined (JRD_PROJECT_POP45C)||defined (JRD_PROJECT_POP455C)
	if(ret_battery_id == SCUD_ID)
	{
		//printk(KERN_ERR "%s x= %d,y=%d",__func__,adcmap_btm_threshold_scud[0].x,adcmap_btm_threshold_scud[0].y);
		return qpnp_adc_map_temp_voltage(
			adcmap_btm_threshold_scud,
			ARRAY_SIZE(adcmap_btm_threshold_scud),
			bat_voltage,
			&adc_chan_result->physical);
	}
	else
	{
		return qpnp_adc_map_temp_voltage(
			adcmap_btm_threshold,
			ARRAY_SIZE(adcmap_btm_threshold),
			bat_voltage,
			&adc_chan_result->physical);
	}
//[Feature]-Add-BEGIN by TCTSZ.Del qcom for get temp baili.ouyang.sz@tcl.com, 2016/1/15, for Task523741
//[Feature]-Add-BEGIN by huichen@tcl.com, 2016/02/19, for alm 1561781
#elif defined (JRD_PROJECT_PIXI464G) || defined (JRD_PROJECT_PIXI464GCRICKET)
	if(PIXI464G_ret_battery_id == PIXI464G_SCUD_ID)
	{
//		printk(KERN_ERR "qpnp_adc_scale_batt_therm PIXI464G_SCUD_ID\n");
		return qpnp_adc_map_temp_voltage(
			adcmap_btm_threshold_scud,
			ARRAY_SIZE(adcmap_btm_threshold_scud),
			bat_voltage,
			&adc_chan_result->physical);
	}
	else
	{
//		printk(KERN_ERR "qpnp_adc_scale_batt_therm PIXI464G_JN_ID\n");
		return qpnp_adc_map_temp_voltage(
			adcmap_btm_threshold,
			ARRAY_SIZE(adcmap_btm_threshold),
			bat_voltage,
			&adc_chan_result->physical);
	}
//[Feature]-Add-END by huichen@tcl.com
//[Feature]-Add-BEGIN by TCTSZ.Del qcom for batt-id-tmp baili.ouyang.sz@tcl.com, 2016/4/22, for Task1163258
#elif defined (JRD_PROJECT_POP45)
	//printk(KERN_ERR "%s gpio_board_id = %d\n",__func__,gpio_board_id);
	if(ret_battery_id == BYD_ID)
	{
	//	printk(KERN_ERR "%s x= %d,y=%d\n",__func__,adcmap_btm_threshold_13k[0].x,adcmap_btm_threshold_13k[0].y);
		return qpnp_adc_map_temp_voltage(
			adcmap_btm_threshold_byd,
			ARRAY_SIZE(adcmap_btm_threshold_byd),
			bat_voltage,
			&adc_chan_result->physical);
	}
	else if(ret_battery_id == JIADE_ID)
	{
		//printk(KERN_ERR "%s x= %d,y=%d\n",__func__,adcmap_btm_threshold[0].x,adcmap_btm_threshold[0].y);
		return qpnp_adc_map_temp_voltage(
			adcmap_btm_threshold_jiade,
			ARRAY_SIZE(adcmap_btm_threshold_jiade),
			bat_voltage,
			&adc_chan_result->physical);
	}
	else
	{
		//printk(KERN_ERR "%s x= %d,y=%d\n",__func__,adcmap_btm_threshold[0].x,adcmap_btm_threshold[0].y);
		return qpnp_adc_map_temp_voltage(
			adcmap_btm_threshold,
			ARRAY_SIZE(adcmap_btm_threshold),
			bat_voltage,
			&adc_chan_result->physical);
	}
//[Feature]-Add-END by TCTSZ.baili.ouyang.sz@tcl.com, 2016/4/22, for Task1163258
#else
	return qpnp_adc_map_temp_voltage(
			adcmap_btm_threshold,
			ARRAY_SIZE(adcmap_btm_threshold),
			bat_voltage,
			&adc_chan_result->physical);
#endif
//add by junfeng.zhou end
}
EXPORT_SYMBOL(qpnp_adc_scale_batt_therm);

int32_t qpnp_adc_scale_qrd_batt_therm(struct qpnp_vadc_chip *chip,
		int32_t adc_code,
		const struct qpnp_adc_properties *adc_properties,
		const struct qpnp_vadc_chan_properties *chan_properties,
		struct qpnp_vadc_result *adc_chan_result)
{
	int64_t bat_voltage = 0;

	bat_voltage = qpnp_adc_scale_ratiometric_calib(adc_code,
			adc_properties, chan_properties);

	adc_chan_result->measurement = bat_voltage;

	return qpnp_adc_map_temp_voltage(
			adcmap_qrd_btm_threshold,
			ARRAY_SIZE(adcmap_qrd_btm_threshold),
			bat_voltage,
			&adc_chan_result->physical);
}
EXPORT_SYMBOL(qpnp_adc_scale_qrd_batt_therm);

int32_t qpnp_adc_scale_qrd_skuaa_batt_therm(struct qpnp_vadc_chip *chip,
		int32_t adc_code,
		const struct qpnp_adc_properties *adc_properties,
		const struct qpnp_vadc_chan_properties *chan_properties,
		struct qpnp_vadc_result *adc_chan_result)
{
	int64_t bat_voltage = 0;

	bat_voltage = qpnp_adc_scale_ratiometric_calib(adc_code,
			adc_properties, chan_properties);

	adc_chan_result->measurement = bat_voltage;

	return qpnp_adc_map_temp_voltage(
			adcmap_qrd_skuaa_btm_threshold,
			ARRAY_SIZE(adcmap_qrd_skuaa_btm_threshold),
			bat_voltage,
			&adc_chan_result->physical);
}
EXPORT_SYMBOL(qpnp_adc_scale_qrd_skuaa_batt_therm);

int32_t qpnp_adc_scale_qrd_skug_batt_therm(struct qpnp_vadc_chip *chip,
		int32_t adc_code,
		const struct qpnp_adc_properties *adc_properties,
		const struct qpnp_vadc_chan_properties *chan_properties,
		struct qpnp_vadc_result *adc_chan_result)
{
	int64_t bat_voltage = 0;

	bat_voltage = qpnp_adc_scale_ratiometric_calib(adc_code,
			adc_properties, chan_properties);

	adc_chan_result->measurement = bat_voltage;

	return qpnp_adc_map_temp_voltage(
			adcmap_qrd_skug_btm_threshold,
			ARRAY_SIZE(adcmap_qrd_skug_btm_threshold),
			bat_voltage,
			&adc_chan_result->physical);
}
EXPORT_SYMBOL(qpnp_adc_scale_qrd_skug_batt_therm);

int32_t qpnp_adc_scale_qrd_skuh_batt_therm(struct qpnp_vadc_chip *chip,
		int32_t adc_code,
		const struct qpnp_adc_properties *adc_properties,
		const struct qpnp_vadc_chan_properties *chan_properties,
		struct qpnp_vadc_result *adc_chan_result)
{
	int64_t bat_voltage = 0;

	bat_voltage = qpnp_adc_scale_ratiometric_calib(adc_code,
			adc_properties, chan_properties);

	return qpnp_adc_map_temp_voltage(
			adcmap_qrd_skuh_btm_threshold,
			ARRAY_SIZE(adcmap_qrd_skuh_btm_threshold),
			bat_voltage,
			&adc_chan_result->physical);
}
EXPORT_SYMBOL(qpnp_adc_scale_qrd_skuh_batt_therm);

int32_t qpnp_adc_scale_qrd_skuc_batt_therm(struct qpnp_vadc_chip *chip,
			int32_t adc_code,
			const struct qpnp_adc_properties *adc_properties,
			const struct qpnp_vadc_chan_properties *chan_properties,
			struct qpnp_vadc_result *adc_chan_result)
{
	int64_t bat_voltage = 0;

	bat_voltage = qpnp_adc_scale_ratiometric_calib(adc_code,
			adc_properties, chan_properties);

	return qpnp_adc_map_temp_voltage(
			adcmap_qrd_skuc_btm_threshold,
			ARRAY_SIZE(adcmap_qrd_skuc_btm_threshold),
			bat_voltage,
			&adc_chan_result->physical);
}
EXPORT_SYMBOL(qpnp_adc_scale_qrd_skuc_batt_therm);

int32_t qpnp_adc_scale_qrd_skue_batt_therm(struct qpnp_vadc_chip *chip,
			int32_t adc_code,
			const struct qpnp_adc_properties *adc_properties,
			const struct qpnp_vadc_chan_properties *chan_properties,
			struct qpnp_vadc_result *adc_chan_result)
{
	int64_t bat_voltage = 0;

	bat_voltage = qpnp_adc_scale_ratiometric_calib(adc_code,
			adc_properties, chan_properties);

	return qpnp_adc_map_temp_voltage(
			adcmap_qrd_skue_btm_threshold,
			ARRAY_SIZE(adcmap_qrd_skue_btm_threshold),
			bat_voltage,
			&adc_chan_result->physical);
}
EXPORT_SYMBOL(qpnp_adc_scale_qrd_skue_batt_therm);

int32_t qpnp_adc_scale_qrd_skul_batt_therm(struct qpnp_vadc_chip *chip,
			int32_t adc_code,
			const struct qpnp_adc_properties *adc_properties,
			const struct qpnp_vadc_chan_properties *chan_properties,
			struct qpnp_vadc_result *adc_chan_result)
{
	int64_t bat_voltage = 0;

	bat_voltage = qpnp_adc_scale_ratiometric_calib(adc_code,
			adc_properties, chan_properties);

	return qpnp_adc_map_temp_voltage(
			adcmap_qrd_skul_btm_threshold,
			ARRAY_SIZE(adcmap_qrd_skul_btm_threshold),
			bat_voltage,
			&adc_chan_result->physical);
}
EXPORT_SYMBOL(qpnp_adc_scale_qrd_skul_batt_therm);

int32_t qpnp_adc_scale_smb_batt_therm(struct qpnp_vadc_chip *chip,
		int32_t adc_code,
		const struct qpnp_adc_properties *adc_properties,
		const struct qpnp_vadc_chan_properties *chan_properties,
		struct qpnp_vadc_result *adc_chan_result)
{
	int64_t bat_voltage = 0;

	bat_voltage = qpnp_adc_scale_ratiometric_calib(adc_code,
			adc_properties, chan_properties);

	return qpnp_adc_map_temp_voltage(
			adcmap_smb_batt_therm,
			ARRAY_SIZE(adcmap_smb_batt_therm),
			bat_voltage,
			&adc_chan_result->physical);
}
EXPORT_SYMBOL(qpnp_adc_scale_smb_batt_therm);

int32_t qpnp_adc_scale_therm_pu1(struct qpnp_vadc_chip *chip,
		int32_t adc_code,
		const struct qpnp_adc_properties *adc_properties,
		const struct qpnp_vadc_chan_properties *chan_properties,
		struct qpnp_vadc_result *adc_chan_result)
{
	int64_t therm_voltage = 0;

	therm_voltage = qpnp_adc_scale_ratiometric_calib(adc_code,
			adc_properties, chan_properties);

	qpnp_adc_map_voltage_temp(adcmap_150k_104ef_104fb,
		ARRAY_SIZE(adcmap_150k_104ef_104fb),
		therm_voltage, &adc_chan_result->physical);

	return 0;
}
EXPORT_SYMBOL(qpnp_adc_scale_therm_pu1);

int32_t qpnp_adc_scale_therm_pu2(struct qpnp_vadc_chip *chip,
		int32_t adc_code,
		const struct qpnp_adc_properties *adc_properties,
		const struct qpnp_vadc_chan_properties *chan_properties,
		struct qpnp_vadc_result *adc_chan_result)
{
	int64_t therm_voltage = 0;

	therm_voltage = qpnp_adc_scale_ratiometric_calib(adc_code,
			adc_properties, chan_properties);

	qpnp_adc_map_voltage_temp(adcmap_100k_104ef_104fb,
		ARRAY_SIZE(adcmap_100k_104ef_104fb),
		therm_voltage, &adc_chan_result->physical);

	return 0;
}
EXPORT_SYMBOL(qpnp_adc_scale_therm_pu2);

int32_t qpnp_adc_tm_scale_voltage_therm_pu2(struct qpnp_vadc_chip *chip,
					uint32_t reg, int64_t *result)
{
	int64_t adc_voltage = 0;
	struct qpnp_vadc_linear_graph param1;
	int negative_offset;

	qpnp_get_vadc_gain_and_offset(chip, &param1, CALIB_RATIOMETRIC);

	adc_voltage = (reg - param1.adc_gnd) * param1.adc_vref;
	if (adc_voltage < 0) {
		negative_offset = 1;
		adc_voltage = -adc_voltage;
	}

	do_div(adc_voltage, param1.dy);

	qpnp_adc_map_voltage_temp(adcmap_100k_104ef_104fb,
		ARRAY_SIZE(adcmap_100k_104ef_104fb),
		adc_voltage, result);
	if (negative_offset)
		adc_voltage = -adc_voltage;

	return 0;
}
EXPORT_SYMBOL(qpnp_adc_tm_scale_voltage_therm_pu2);

int32_t qpnp_adc_tm_scale_therm_voltage_pu2(struct qpnp_vadc_chip *chip,
				struct qpnp_adc_tm_config *param)
{
	struct qpnp_vadc_linear_graph param1;
	int rc;

	qpnp_get_vadc_gain_and_offset(chip, &param1, CALIB_RATIOMETRIC);

	rc = qpnp_adc_map_temp_voltage(adcmap_100k_104ef_104fb,
		ARRAY_SIZE(adcmap_100k_104ef_104fb),
		param->low_thr_temp, &param->low_thr_voltage);
	if (rc)
		return rc;

	param->low_thr_voltage *= param1.dy;
	do_div(param->low_thr_voltage, param1.adc_vref);
	param->low_thr_voltage += param1.adc_gnd;

	rc = qpnp_adc_map_temp_voltage(adcmap_100k_104ef_104fb,
		ARRAY_SIZE(adcmap_100k_104ef_104fb),
		param->high_thr_temp, &param->high_thr_voltage);
	if (rc)
		return rc;

	param->high_thr_voltage *= param1.dy;
	do_div(param->high_thr_voltage, param1.adc_vref);
	param->high_thr_voltage += param1.adc_gnd;

	return 0;
}
EXPORT_SYMBOL(qpnp_adc_tm_scale_therm_voltage_pu2);

int32_t qpnp_adc_scale_therm_ncp03(struct qpnp_vadc_chip *chip,
		int32_t adc_code,
		const struct qpnp_adc_properties *adc_properties,
		const struct qpnp_vadc_chan_properties *chan_properties,
		struct qpnp_vadc_result *adc_chan_result)
{
	int64_t therm_voltage = 0;

	therm_voltage = qpnp_adc_scale_ratiometric_calib(adc_code,
			adc_properties, chan_properties);

	qpnp_adc_map_voltage_temp(adcmap_ncp03wf683,
		ARRAY_SIZE(adcmap_ncp03wf683),
		therm_voltage, &adc_chan_result->physical);

	return 0;
}
EXPORT_SYMBOL(qpnp_adc_scale_therm_ncp03);

int32_t qpnp_adc_scale_batt_id(struct qpnp_vadc_chip *chip,
		int32_t adc_code,
		const struct qpnp_adc_properties *adc_properties,
		const struct qpnp_vadc_chan_properties *chan_properties,
		struct qpnp_vadc_result *adc_chan_result)
{
	int64_t batt_id_voltage = 0;

	batt_id_voltage = qpnp_adc_scale_ratiometric_calib(adc_code,
			adc_properties, chan_properties);
	adc_chan_result->physical = batt_id_voltage;
	adc_chan_result->physical = adc_chan_result->measurement;

	return 0;
}
EXPORT_SYMBOL(qpnp_adc_scale_batt_id);

int32_t qpnp_adc_scale_default(struct qpnp_vadc_chip *vadc,
		int32_t adc_code,
		const struct qpnp_adc_properties *adc_properties,
		const struct qpnp_vadc_chan_properties *chan_properties,
		struct qpnp_vadc_result *adc_chan_result)
{
	bool negative_rawfromoffset = 0, negative_offset = 0;
	int64_t scale_voltage = 0;

	if (!chan_properties || !chan_properties->offset_gain_numerator ||
		!chan_properties->offset_gain_denominator || !adc_properties
		|| !adc_chan_result)
		return -EINVAL;

	scale_voltage = (adc_code -
		chan_properties->adc_graph[chan_properties->calib_type].adc_gnd)
		* chan_properties->adc_graph[chan_properties->calib_type].dx;
	if (scale_voltage < 0) {
		negative_offset = 1;
		scale_voltage = -scale_voltage;
	}
	do_div(scale_voltage,
		chan_properties->adc_graph[chan_properties->calib_type].dy);
	if (negative_offset)
		scale_voltage = -scale_voltage;

	if (chan_properties->calib_type == CALIB_ABSOLUTE)
		scale_voltage +=
		chan_properties->adc_graph[chan_properties->calib_type].dx;
	else
		scale_voltage *= 1000;

	if (scale_voltage < 0) {
		if (adc_properties->bipolar) {
			scale_voltage = -scale_voltage;
			negative_rawfromoffset = 1;
		} else {
			scale_voltage = 0;
		}
	}

	adc_chan_result->measurement = scale_voltage *
				chan_properties->offset_gain_denominator;

	/* do_div only perform positive integer division! */
	do_div(adc_chan_result->measurement,
				chan_properties->offset_gain_numerator);

	if (negative_rawfromoffset)
		adc_chan_result->measurement = -adc_chan_result->measurement;

	/*
	 * Note: adc_chan_result->measurement is in the unit of
	 * adc_properties.adc_reference. For generic channel processing,
	 * channel measurement is a scale/ratio relative to the adc
	 * reference input
	 */
	adc_chan_result->physical = adc_chan_result->measurement;

	return 0;
}
EXPORT_SYMBOL(qpnp_adc_scale_default);

int32_t qpnp_adc_usb_scaler(struct qpnp_vadc_chip *chip,
		struct qpnp_adc_tm_btm_param *param,
		uint32_t *low_threshold, uint32_t *high_threshold)
{
	struct qpnp_vadc_linear_graph usb_param;

	qpnp_get_vadc_gain_and_offset(chip, &usb_param, CALIB_RATIOMETRIC);

	*low_threshold = param->low_thr * usb_param.dy;
	do_div(*low_threshold, usb_param.adc_vref);
	*low_threshold += usb_param.adc_gnd;

	*high_threshold = param->high_thr * usb_param.dy;
	do_div(*high_threshold, usb_param.adc_vref);
	*high_threshold += usb_param.adc_gnd;

	pr_debug("high_volt:%d, low_volt:%d\n", param->high_thr,
				param->low_thr);
	return 0;
}
EXPORT_SYMBOL(qpnp_adc_usb_scaler);

int32_t qpnp_adc_vbatt_rscaler(struct qpnp_vadc_chip *chip,
		struct qpnp_adc_tm_btm_param *param,
		uint32_t *low_threshold, uint32_t *high_threshold)
{
	struct qpnp_vadc_linear_graph vbatt_param;
	int rc = 0, sign = 0;
	int64_t low_thr = 0, high_thr = 0;

	rc = qpnp_get_vadc_gain_and_offset(chip, &vbatt_param, CALIB_ABSOLUTE);
	if (rc < 0)
		return rc;

	low_thr = (((param->low_thr/3) - QPNP_ADC_625_UV) *
				vbatt_param.dy);
	if (low_thr < 0) {
		sign = 1;
		low_thr = -low_thr;
	}
	do_div(low_thr, QPNP_ADC_625_UV);
	if (sign)
		low_thr = -low_thr;
	*low_threshold = low_thr + vbatt_param.adc_gnd;

	sign = 0;
	high_thr = (((param->high_thr/3) - QPNP_ADC_625_UV) *
				vbatt_param.dy);
	if (high_thr < 0) {
		sign = 1;
		high_thr = -high_thr;
	}
	do_div(high_thr, QPNP_ADC_625_UV);
	if (sign)
		high_thr = -high_thr;
	*high_threshold = high_thr + vbatt_param.adc_gnd;

	pr_debug("high_volt:%d, low_volt:%d\n", param->high_thr,
				param->low_thr);
	pr_debug("adc_code_high:%x, adc_code_low:%x\n", *high_threshold,
				*low_threshold);
	return 0;
}
EXPORT_SYMBOL(qpnp_adc_vbatt_rscaler);

int32_t qpnp_adc_absolute_rthr(struct qpnp_vadc_chip *chip,
		struct qpnp_adc_tm_btm_param *param,
		uint32_t *low_threshold, uint32_t *high_threshold)
{
	struct qpnp_vadc_linear_graph vbatt_param;
	int rc = 0, sign = 0;
	int64_t low_thr = 0, high_thr = 0;

	rc = qpnp_get_vadc_gain_and_offset(chip, &vbatt_param, CALIB_ABSOLUTE);
	if (rc < 0)
		return rc;

	low_thr = (((param->low_thr) - QPNP_ADC_625_UV) * vbatt_param.dy);
	if (low_thr < 0) {
		sign = 1;
		low_thr = -low_thr;
	}
	do_div(low_thr, QPNP_ADC_625_UV);
	if (sign)
		low_thr = -low_thr;
	*low_threshold = low_thr + vbatt_param.adc_gnd;

	sign = 0;
	high_thr = (((param->high_thr) - QPNP_ADC_625_UV) * vbatt_param.dy);
	if (high_thr < 0) {
		sign = 1;
		high_thr = -high_thr;
	}
	do_div(high_thr, QPNP_ADC_625_UV);
	if (sign)
		high_thr = -high_thr;
	*high_threshold = high_thr + vbatt_param.adc_gnd;

	pr_debug("high_volt:%d, low_volt:%d\n", param->high_thr,
				param->low_thr);
	pr_debug("adc_code_high:%x, adc_code_low:%x\n", *high_threshold,
				*low_threshold);
	return 0;
}
EXPORT_SYMBOL(qpnp_adc_absolute_rthr);

int32_t qpnp_vadc_absolute_rthr(struct qpnp_vadc_chip *chip,
		const struct qpnp_vadc_chan_properties *chan_prop,
		struct qpnp_adc_tm_btm_param *param,
		uint32_t *low_threshold, uint32_t *high_threshold)
{
	struct qpnp_vadc_linear_graph vbatt_param;
	int rc = 0, sign = 0;
	int64_t low_thr = 0, high_thr = 0;

	if (!chan_prop || !chan_prop->offset_gain_numerator ||
		!chan_prop->offset_gain_denominator)
		return -EINVAL;

	rc = qpnp_get_vadc_gain_and_offset(chip, &vbatt_param, CALIB_ABSOLUTE);
	if (rc < 0)
		return rc;

	low_thr = (((param->low_thr)/chan_prop->offset_gain_denominator
					- QPNP_ADC_625_UV) * vbatt_param.dy);
	if (low_thr < 0) {
		sign = 1;
		low_thr = -low_thr;
	}
	low_thr = low_thr * chan_prop->offset_gain_numerator;
	do_div(low_thr, QPNP_ADC_625_UV);
	if (sign)
		low_thr = -low_thr;
	*low_threshold = low_thr + vbatt_param.adc_gnd;

	sign = 0;
	high_thr = (((param->high_thr)/chan_prop->offset_gain_denominator
					- QPNP_ADC_625_UV) * vbatt_param.dy);
	if (high_thr < 0) {
		sign = 1;
		high_thr = -high_thr;
	}
	high_thr = high_thr * chan_prop->offset_gain_numerator;
	do_div(high_thr, QPNP_ADC_625_UV);
	if (sign)
		high_thr = -high_thr;
	*high_threshold = high_thr + vbatt_param.adc_gnd;

	pr_debug("high_volt:%d, low_volt:%d\n", param->high_thr,
				param->low_thr);
	pr_debug("adc_code_high:%x, adc_code_low:%x\n", *high_threshold,
				*low_threshold);
	return 0;
}
EXPORT_SYMBOL(qpnp_vadc_absolute_rthr);

int32_t qpnp_adc_btm_scaler(struct qpnp_vadc_chip *chip,
		struct qpnp_adc_tm_btm_param *param,
		uint32_t *low_threshold, uint32_t *high_threshold)
{
	struct qpnp_vadc_linear_graph btm_param;
	int64_t low_output = 0, high_output = 0;
	int rc = 0;

	qpnp_get_vadc_gain_and_offset(chip, &btm_param, CALIB_RATIOMETRIC);

	pr_debug("warm_temp:%d and cool_temp:%d\n", param->high_temp,
				param->low_temp);
//add by junfeng.zhou for make  two battery's ntc adcmap compatibility begin
#if defined (JRD_PROJECT_POP45C)||defined (JRD_PROJECT_POP455C)
	if(ret_battery_id == SCUD_ID)
	{
		//printk(KERN_ERR "%s x= %d,y=%d",__func__,adcmap_btm_threshold_scud[0].x,adcmap_btm_threshold_scud[0].y);
		rc = qpnp_adc_map_voltage_temp(
		adcmap_btm_threshold_scud,
		ARRAY_SIZE(adcmap_btm_threshold_scud),
		(param->low_temp),
		&low_output);
		if (rc) {
			pr_debug("low_temp mapping failed with %d\n", rc);
			return rc;
		}
	}
	else
	{
		rc = qpnp_adc_map_voltage_temp(
		adcmap_btm_threshold,
		ARRAY_SIZE(adcmap_btm_threshold),
		(param->low_temp),
		&low_output);
		if (rc) {
			pr_debug("low_temp mapping failed with %d\n", rc);
			return rc;
		}
	}
//[Feature]-Add-BEGIN by TCTSZ.Del qcom for batt-id-tmp baili.ouyang.sz@tcl.com, 2016/4/22, for Task1163258
#elif defined (JRD_PROJECT_POP45)
	if(ret_battery_id == BYD_ID)
	{
		//printk(KERN_ERR "%s x= %d,y=%d",__func__,adcmap_btm_threshold_scud[0].x,adcmap_btm_threshold_scud[0].y);
		rc = qpnp_adc_map_voltage_temp(
		adcmap_btm_threshold_byd,
		ARRAY_SIZE(adcmap_btm_threshold_byd),
		(param->low_temp),
		&low_output);
		if (rc) {
			pr_debug("low_temp mapping failed with %d\n", rc);
			return rc;
		}
	}
	else if(ret_battery_id == JIADE_ID)
	{
		rc = qpnp_adc_map_voltage_temp(
		adcmap_btm_threshold_jiade,
		ARRAY_SIZE(adcmap_btm_threshold_jiade),
		(param->low_temp),
		&low_output);
		if (rc) {
			pr_debug("low_temp mapping failed with %d\n", rc);
			return rc;
		}
	}
	else
	{
		rc = qpnp_adc_map_voltage_temp(
		adcmap_btm_threshold,
		ARRAY_SIZE(adcmap_btm_threshold),
		(param->low_temp),
		&low_output);
		if (rc) {
			pr_debug("low_temp mapping failed with %d\n", rc);
			return rc;
		}
	}
//[Feature]-Add-END by TCTSZ.baili.ouyang.sz@tcl.com, 2016/4/22, for Task1163258
//[Feature]-Add-BEGIN by huichen@tcl.com, 2016/02/19, for alm 1561781
#elif defined (JRD_PROJECT_PIXI464G) || defined (JRD_PROJECT_PIXI464GCRICKET)
if(PIXI464G_ret_battery_id == PIXI464G_SCUD_ID)
{
//	printk(KERN_ERR "qpnp_adc_btm_scaler PIXI464G_SCUD_ID\n");
	rc = qpnp_adc_map_voltage_temp(
	adcmap_btm_threshold_scud,
	ARRAY_SIZE(adcmap_btm_threshold_scud),
	(param->low_temp),
	&low_output);
	if (rc) {
		pr_debug("low_temp mapping failed with %d\n", rc);
		return rc;
	}
}
else
{
//	printk(KERN_ERR "qpnp_adc_btm_scaler PIXI464G_JN_ID\n");
	rc = qpnp_adc_map_voltage_temp(
	adcmap_btm_threshold,
	ARRAY_SIZE(adcmap_btm_threshold),
	(param->low_temp),
	&low_output);
	if (rc) {
		pr_debug("low_temp mapping failed with %d\n", rc);
		return rc;
	}
}
//[Feature]-Add-END by huichen@tcl.com
#else
	rc = qpnp_adc_map_voltage_temp(
		adcmap_btm_threshold,
		ARRAY_SIZE(adcmap_btm_threshold),
		(param->low_temp),
		&low_output);
	if (rc) {
		pr_debug("low_temp mapping failed with %d\n", rc);
		return rc;
	}
#endif
//add by junfeng.zhou end
	pr_debug("low_output:%lld\n", low_output);
	low_output *= btm_param.dy;
	do_div(low_output, btm_param.adc_vref);
	low_output += btm_param.adc_gnd;
//add by junfeng.zhou for make  two battery's ntc adcmap compatibility begin
#if defined (JRD_PROJECT_POP45C)||defined (JRD_PROJECT_POP455C)
	if(ret_battery_id == SCUD_ID)
	{
		//printk(KERN_ERR "%s x= %d,y=%d",__func__,adcmap_btm_threshold_scud[0].x,adcmap_btm_threshold_scud[0].y);
		rc = qpnp_adc_map_voltage_temp(
			adcmap_btm_threshold_scud,
			ARRAY_SIZE(adcmap_btm_threshold_scud),
			(param->high_temp),
			&high_output);
		if (rc) {
			pr_debug("high temp mapping failed with %d\n", rc);
			return rc;
		}
	}
	else
	{
		rc = qpnp_adc_map_voltage_temp(
			adcmap_btm_threshold,
			ARRAY_SIZE(adcmap_btm_threshold),
			(param->high_temp),
			&high_output);
		if (rc) {
			pr_debug("high temp mapping failed with %d\n", rc);
			return rc;
		}
	}
//[Feature]-Add-BEGIN by TCTSZ.Del qcom for batt-id-tmp baili.ouyang.sz@tcl.com, 2016/4/22, for Task1163258
#elif defined (JRD_PROJECT_POP45)
	if(ret_battery_id == BYD_ID)
	{
		//printk(KERN_ERR "BYD_ID:%s ret_battery_id =%d,x= %d,y=%d",__func__,ret_battery_id,adcmap_btm_threshold_byd[0].x,adcmap_btm_threshold_byd[0].y);
		rc = qpnp_adc_map_voltage_temp(
			adcmap_btm_threshold_byd,
			ARRAY_SIZE(adcmap_btm_threshold_byd),
			(param->high_temp),
			&high_output);
		if (rc) {
			pr_debug("high temp mapping failed with %d\n", rc);
			return rc;
		}
	}
	else if(ret_battery_id == JIADE_ID)
	{
		//printk(KERN_ERR "JIADE_ID:%s ret_battery_id =%d,x= %d,y=%d",__func__,ret_battery_id,adcmap_btm_threshold_jiade[0].x,adcmap_btm_threshold_jiade[0].y);
		rc = qpnp_adc_map_voltage_temp(
			adcmap_btm_threshold_jiade,
			ARRAY_SIZE(adcmap_btm_threshold_jiade),
			(param->high_temp),
			&high_output);
		if (rc) {
			pr_debug("high temp mapping failed with %d\n", rc);
			return rc;
		}
	}
	else
	{
		//printk(KERN_ERR "VEKEN_ID:%s ret_battery_id =%d,x= %d,y=%d",__func__,ret_battery_id,adcmap_btm_threshold[0].x,adcmap_btm_threshold[0].y);
		rc = qpnp_adc_map_voltage_temp(
			adcmap_btm_threshold,
			ARRAY_SIZE(adcmap_btm_threshold),
			(param->high_temp),
			&high_output);
		if (rc) {
			pr_debug("high temp mapping failed with %d\n", rc);
			return rc;
		}
	}

//[Feature]-Add-END by TCTSZ.baili.ouyang.sz@tcl.com, 2016/4/22, for Task1163258
//[Feature]-Add-BEGIN by huichen@tcl.com, 2016/02/19, for alm 1561781
#elif defined (JRD_PROJECT_PIXI464G) || defined (JRD_PROJECT_PIXI464GCRICKET)
	if(PIXI464G_ret_battery_id == PIXI464G_SCUD_ID)
	{
//		printk(KERN_ERR "qpnp_adc_btm_scaler PIXI464G_SCUD_ID\n");
		rc = qpnp_adc_map_voltage_temp(
			adcmap_btm_threshold_scud,
			ARRAY_SIZE(adcmap_btm_threshold_scud),
			(param->high_temp),
			&high_output);
		if (rc) {
			pr_debug("high temp mapping failed with %d\n", rc);
			return rc;
		}
	}
	else
	{
//		printk(KERN_ERR "qpnp_adc_btm_scaler PIXI464G_JN_ID\n");
		rc = qpnp_adc_map_voltage_temp(
			adcmap_btm_threshold,
			ARRAY_SIZE(adcmap_btm_threshold),
			(param->high_temp),
			&high_output);
		if (rc) {
			pr_debug("high temp mapping failed with %d\n", rc);
			return rc;
		}
	}
//[Feature]-Add-END by huichen@tcl.com
#else
	rc = qpnp_adc_map_voltage_temp(
		adcmap_btm_threshold,
		ARRAY_SIZE(adcmap_btm_threshold),
		(param->high_temp),
		&high_output);
	if (rc) {
		pr_debug("high temp mapping failed with %d\n", rc);
		return rc;
	}
#endif
//add by junfeng.zhou end
	pr_debug("high_output:%lld\n", high_output);
	high_output *= btm_param.dy;
	do_div(high_output, btm_param.adc_vref);
	high_output += btm_param.adc_gnd;

	/* btm low temperature correspondes to high voltage threshold */
	*low_threshold = high_output;
	/* btm high temperature correspondes to low voltage threshold */
	*high_threshold = low_output;

	pr_debug("high_volt:%d, low_volt:%d\n", *high_threshold,
				*low_threshold);
	return 0;
}
EXPORT_SYMBOL(qpnp_adc_btm_scaler);

int32_t qpnp_adc_qrd_skuh_btm_scaler(struct qpnp_vadc_chip *chip,
		struct qpnp_adc_tm_btm_param *param,
		uint32_t *low_threshold, uint32_t *high_threshold)
{
	struct qpnp_vadc_linear_graph btm_param;
	int64_t low_output = 0, high_output = 0;
	int rc = 0;

	qpnp_get_vadc_gain_and_offset(chip, &btm_param, CALIB_RATIOMETRIC);

	pr_debug("warm_temp:%d and cool_temp:%d\n", param->high_temp,
				param->low_temp);
	rc = qpnp_adc_map_voltage_temp(
		adcmap_qrd_skuh_btm_threshold,
		ARRAY_SIZE(adcmap_qrd_skuh_btm_threshold),
		(param->low_temp),
		&low_output);
	if (rc) {
		pr_debug("low_temp mapping failed with %d\n", rc);
		return rc;
	}

	pr_debug("low_output:%lld\n", low_output);
	low_output *= btm_param.dy;
	do_div(low_output, btm_param.adc_vref);
	low_output += btm_param.adc_gnd;

	rc = qpnp_adc_map_voltage_temp(
		adcmap_qrd_skuh_btm_threshold,
		ARRAY_SIZE(adcmap_qrd_skuh_btm_threshold),
		(param->high_temp),
		&high_output);
	if (rc) {
		pr_debug("high temp mapping failed with %d\n", rc);
		return rc;
	}

	pr_debug("high_output:%lld\n", high_output);
	high_output *= btm_param.dy;
	do_div(high_output, btm_param.adc_vref);
	high_output += btm_param.adc_gnd;

	/* btm low temperature correspondes to high voltage threshold */
	*low_threshold = high_output;
	/* btm high temperature correspondes to low voltage threshold */
	*high_threshold = low_output;

	pr_debug("high_volt:%d, low_volt:%d\n", *high_threshold,
				*low_threshold);
	return 0;
}
EXPORT_SYMBOL(qpnp_adc_qrd_skuh_btm_scaler);

int32_t qpnp_adc_qrd_skue_btm_scaler(struct qpnp_vadc_chip *chip,
		struct qpnp_adc_tm_btm_param *param,
		uint32_t *low_threshold, uint32_t *high_threshold)
{
	struct qpnp_vadc_linear_graph btm_param;
	int64_t low_output = 0, high_output = 0;
	int rc = 0;

	qpnp_get_vadc_gain_and_offset(chip, &btm_param, CALIB_RATIOMETRIC);

	pr_debug("warm_temp:%d and cool_temp:%d\n", param->high_temp,
				param->low_temp);
	rc = qpnp_adc_map_voltage_temp(
		adcmap_qrd_skue_btm_threshold,
		ARRAY_SIZE(adcmap_qrd_skue_btm_threshold),
		(param->low_temp),
		&low_output);
	if (rc) {
		pr_debug("low_temp mapping failed with %d\n", rc);
		return rc;
	}

	pr_debug("low_output:%lld\n", low_output);
	low_output *= btm_param.dy;
	do_div(low_output, btm_param.adc_vref);
	low_output += btm_param.adc_gnd;

	rc = qpnp_adc_map_voltage_temp(
		adcmap_qrd_skue_btm_threshold,
		ARRAY_SIZE(adcmap_qrd_skue_btm_threshold),
		(param->high_temp),
		&high_output);
	if (rc) {
		pr_debug("high temp mapping failed with %d\n", rc);
		return rc;
	}

	pr_debug("high_output:%lld\n", high_output);
	high_output *= btm_param.dy;
	do_div(high_output, btm_param.adc_vref);
	high_output += btm_param.adc_gnd;

	/* btm low temperature correspondes to high voltage threshold */
	*low_threshold = high_output;
	/* btm high temperature correspondes to low voltage threshold */
	*high_threshold = low_output;

	pr_debug("high_volt:%d, low_volt:%d\n", *high_threshold,
				*low_threshold);
	return 0;
}
EXPORT_SYMBOL(qpnp_adc_qrd_skue_btm_scaler);

int32_t qpnp_adc_smb_btm_rscaler(struct qpnp_vadc_chip *chip,
		struct qpnp_adc_tm_btm_param *param,
		uint32_t *low_threshold, uint32_t *high_threshold)
{
	struct qpnp_vadc_linear_graph btm_param;
	int64_t low_output = 0, high_output = 0;
	int rc = 0;

	qpnp_get_vadc_gain_and_offset(chip, &btm_param, CALIB_RATIOMETRIC);

	pr_debug("warm_temp:%d and cool_temp:%d\n", param->high_temp,
				param->low_temp);
	rc = qpnp_adc_map_voltage_temp(
		adcmap_smb_batt_therm,
		ARRAY_SIZE(adcmap_smb_batt_therm),
		(param->low_temp),
		&low_output);
	if (rc) {
		pr_debug("low_temp mapping failed with %d\n", rc);
		return rc;
	}

	pr_debug("low_output:%lld\n", low_output);
	low_output *= btm_param.dy;
	do_div(low_output, btm_param.adc_vref);
	low_output += btm_param.adc_gnd;

	rc = qpnp_adc_map_voltage_temp(
		adcmap_smb_batt_therm,
		ARRAY_SIZE(adcmap_smb_batt_therm),
		(param->high_temp),
		&high_output);
	if (rc) {
		pr_debug("high temp mapping failed with %d\n", rc);
		return rc;
	}

	pr_debug("high_output:%lld\n", high_output);
	high_output *= btm_param.dy;
	do_div(high_output, btm_param.adc_vref);
	high_output += btm_param.adc_gnd;

	/* btm low temperature correspondes to high voltage threshold */
	*low_threshold = high_output;
	/* btm high temperature correspondes to low voltage threshold */
	*high_threshold = low_output;

	pr_debug("high_volt:%d, low_volt:%d\n", *high_threshold,
				*low_threshold);
	return 0;
}
EXPORT_SYMBOL(qpnp_adc_smb_btm_rscaler);

int32_t qpnp_vadc_check_result(int32_t *data, bool recalib_check)
{
	if (recalib_check)
		return 0;

	if (*data < QPNP_VADC_MIN_ADC_CODE)
		*data = QPNP_VADC_MIN_ADC_CODE;
	else if (*data > QPNP_VADC_MAX_ADC_CODE)
		*data = QPNP_VADC_MAX_ADC_CODE;

	return 0;
}
EXPORT_SYMBOL(qpnp_vadc_check_result);

int qpnp_adc_get_revid_version(struct device *dev)
{
	struct pmic_revid_data *revid_data;
	struct device_node *revid_dev_node;

	revid_dev_node = of_parse_phandle(dev->of_node,
						"qcom,pmic-revid", 0);
	if (!revid_dev_node) {
		pr_debug("Missing qcom,pmic-revid property\n");
		return -EINVAL;
	}

	revid_data = get_revid_data(revid_dev_node);
	if (IS_ERR(revid_data)) {
		pr_debug("revid error rc = %ld\n", PTR_ERR(revid_data));
		return -EINVAL;
	}

	if ((revid_data->rev1 == PM8941_V3P1_REV1) &&
		(revid_data->rev2 == PM8941_V3P1_REV2) &&
		(revid_data->rev3 == PM8941_V3P1_REV3) &&
		(revid_data->rev4 == PM8941_V3P1_REV4) &&
		(revid_data->pmic_type == PM8941_V3P1_TYPE) &&
		(revid_data->pmic_subtype == PM8941_V3P1_SUBTYPE))
			return QPNP_REV_ID_8941_3_1;
	else if ((revid_data->rev1 == PM8941_V3P0_REV1) &&
		(revid_data->rev2 == PM8941_V3P0_REV2) &&
		(revid_data->rev3 == PM8941_V3P0_REV3) &&
		(revid_data->rev4 == PM8941_V3P0_REV4) &&
		(revid_data->pmic_type == PM8941_V3P0_TYPE) &&
		(revid_data->pmic_subtype == PM8941_V3P0_SUBTYPE))
			return QPNP_REV_ID_8941_3_0;
	else if ((revid_data->rev1 == PM8941_V2P0_REV1) &&
		(revid_data->rev2 == PM8941_V2P0_REV2) &&
		(revid_data->rev3 == PM8941_V2P0_REV3) &&
		(revid_data->rev4 == PM8941_V2P0_REV4) &&
		(revid_data->pmic_type == PM8941_V2P0_TYPE) &&
		(revid_data->pmic_subtype == PM8941_V2P0_SUBTYPE))
			return QPNP_REV_ID_8941_2_0;
	else if ((revid_data->rev1 == PM8226_V2P2_REV1) &&
		(revid_data->rev2 == PM8226_V2P2_REV2) &&
		(revid_data->rev3 == PM8226_V2P2_REV3) &&
		(revid_data->rev4 == PM8226_V2P2_REV4) &&
		(revid_data->pmic_type == PM8226_V2P2_TYPE) &&
		(revid_data->pmic_subtype == PM8226_V2P2_SUBTYPE))
			return QPNP_REV_ID_8026_2_2;
	else if ((revid_data->rev1 == PM8226_V2P1_REV1) &&
		(revid_data->rev2 == PM8226_V2P1_REV2) &&
		(revid_data->rev3 == PM8226_V2P1_REV3) &&
		(revid_data->rev4 == PM8226_V2P1_REV4) &&
		(revid_data->pmic_type == PM8226_V2P1_TYPE) &&
		(revid_data->pmic_subtype == PM8226_V2P1_SUBTYPE))
			return QPNP_REV_ID_8026_2_1;
	else if ((revid_data->rev1 == PM8226_V2P0_REV1) &&
		(revid_data->rev2 == PM8226_V2P0_REV2) &&
		(revid_data->rev3 == PM8226_V2P0_REV3) &&
		(revid_data->rev4 == PM8226_V2P0_REV4) &&
		(revid_data->pmic_type == PM8226_V2P0_TYPE) &&
		(revid_data->pmic_subtype == PM8226_V2P0_SUBTYPE))
			return QPNP_REV_ID_8026_2_0;
	else if ((revid_data->rev1 == PM8226_V1P0_REV1) &&
		(revid_data->rev2 == PM8226_V1P0_REV2) &&
		(revid_data->rev3 == PM8226_V1P0_REV3) &&
		(revid_data->rev4 == PM8226_V1P0_REV4) &&
		(revid_data->pmic_type == PM8226_V1P0_TYPE) &&
		(revid_data->pmic_subtype == PM8226_V1P0_SUBTYPE))
			return QPNP_REV_ID_8026_1_0;
	else if ((revid_data->rev1 == PM8110_V1P0_REV1) &&
		(revid_data->rev2 == PM8110_V1P0_REV2) &&
		(revid_data->rev3 == PM8110_V1P0_REV3) &&
		(revid_data->rev4 == PM8110_V1P0_REV4) &&
		(revid_data->pmic_type == PM8110_V1P0_TYPE) &&
		(revid_data->pmic_subtype == PM8110_V1P0_SUBTYPE))
			return QPNP_REV_ID_8110_1_0;
	else if ((revid_data->rev1 == PM8110_V2P0_REV1) &&
		(revid_data->rev2 == PM8110_V2P0_REV2) &&
		(revid_data->rev3 == PM8110_V2P0_REV3) &&
		(revid_data->rev4 == PM8110_V2P0_REV4) &&
		(revid_data->pmic_type == PM8110_V2P0_TYPE) &&
		(revid_data->pmic_subtype == PM8110_V2P0_SUBTYPE))
			return QPNP_REV_ID_8110_2_0;
	else if ((revid_data->rev1 == PM8916_V1P0_REV1) &&
		(revid_data->rev2 == PM8916_V1P0_REV2) &&
		(revid_data->rev3 == PM8916_V1P0_REV3) &&
		(revid_data->rev4 == PM8916_V1P0_REV4) &&
		(revid_data->pmic_type == PM8916_V1P0_TYPE) &&
		(revid_data->pmic_subtype == PM8916_V1P0_SUBTYPE))
			return QPNP_REV_ID_8916_1_0;
	else if ((revid_data->rev1 == PM8916_V1P1_REV1) &&
		(revid_data->rev2 == PM8916_V1P1_REV2) &&
		(revid_data->rev3 == PM8916_V1P1_REV3) &&
		(revid_data->rev4 == PM8916_V1P1_REV4) &&
		(revid_data->pmic_type == PM8916_V1P1_TYPE) &&
		(revid_data->pmic_subtype == PM8916_V1P1_SUBTYPE))
			return QPNP_REV_ID_8916_1_1;
	else if ((revid_data->rev1 == PM8916_V2P0_REV1) &&
		(revid_data->rev2 == PM8916_V2P0_REV2) &&
		(revid_data->rev3 == PM8916_V2P0_REV3) &&
		(revid_data->rev4 == PM8916_V2P0_REV4) &&
		(revid_data->pmic_type == PM8916_V2P0_TYPE) &&
		(revid_data->pmic_subtype == PM8916_V2P0_SUBTYPE))
			return QPNP_REV_ID_8916_2_0;
	else if ((revid_data->rev1 == PM8909_V1P0_REV1) &&
		(revid_data->rev2 == PM8909_V1P0_REV2) &&
		(revid_data->rev3 == PM8909_V1P0_REV3) &&
		(revid_data->rev4 == PM8909_V1P0_REV4) &&
		(revid_data->pmic_type == PM8909_V1P0_TYPE) &&
		(revid_data->pmic_subtype == PM8909_V1P0_SUBTYPE))
			return QPNP_REV_ID_8909_1_0;
	else if ((revid_data->rev1 == PM8909_V1P1_REV1) &&
		(revid_data->rev2 == PM8909_V1P1_REV2) &&
		(revid_data->rev3 == PM8909_V1P1_REV3) &&
		(revid_data->rev4 == PM8909_V1P1_REV4) &&
		(revid_data->pmic_type == PM8909_V1P1_TYPE) &&
		(revid_data->pmic_subtype == PM8909_V1P1_SUBTYPE))
			return QPNP_REV_ID_8909_1_1;
	else
		return -EINVAL;
}
EXPORT_SYMBOL(qpnp_adc_get_revid_version);

int32_t qpnp_adc_get_devicetree_data(struct spmi_device *spmi,
			struct qpnp_adc_drv *adc_qpnp)
{
	struct device_node *node = spmi->dev.of_node;
	struct resource *res;
	struct device_node *child;
	struct qpnp_adc_amux *adc_channel_list;
	struct qpnp_adc_properties *adc_prop;
	struct qpnp_adc_amux_properties *amux_prop;
	int count_adc_channel_list = 0, decimation, rc = 0, i = 0;

	if (!node)
		return -EINVAL;

	for_each_child_of_node(node, child)
		count_adc_channel_list++;

	if (!count_adc_channel_list) {
		pr_err("No channel listing\n");
		return -EINVAL;
	}

	adc_qpnp->spmi = spmi;

	adc_prop = devm_kzalloc(&spmi->dev, sizeof(struct qpnp_adc_properties),
					GFP_KERNEL);
	if (!adc_prop) {
		dev_err(&spmi->dev, "Unable to allocate memory\n");
		return -ENOMEM;
	}
	adc_channel_list = devm_kzalloc(&spmi->dev,
		((sizeof(struct qpnp_adc_amux)) * count_adc_channel_list),
				GFP_KERNEL);
	if (!adc_channel_list) {
		dev_err(&spmi->dev, "Unable to allocate memory\n");
		return -ENOMEM;
	}

	amux_prop = devm_kzalloc(&spmi->dev,
		sizeof(struct qpnp_adc_amux_properties) +
		sizeof(struct qpnp_vadc_chan_properties), GFP_KERNEL);
	if (!amux_prop) {
		dev_err(&spmi->dev, "Unable to allocate memory\n");
		return -ENOMEM;
	}

	adc_qpnp->adc_channels = adc_channel_list;
	adc_qpnp->amux_prop = amux_prop;

	for_each_child_of_node(node, child) {
		int channel_num, scaling, post_scaling, hw_settle_time;
		int fast_avg_setup, calib_type = 0, rc;
		const char *calibration_param, *channel_name;

		channel_name = of_get_property(child,
				"label", NULL) ? : child->name;
		if (!channel_name) {
			pr_err("Invalid channel name\n");
			return -EINVAL;
		}

		rc = of_property_read_u32(child, "reg", &channel_num);
		if (rc) {
			pr_err("Invalid channel num\n");
			return -EINVAL;
		}
		rc = of_property_read_u32(child, "qcom,decimation",
								&decimation);
		if (rc) {
			pr_err("Invalid channel decimation property\n");
			return -EINVAL;
		}
		if (!of_device_is_compatible(node, "qcom,qpnp-iadc")) {
			rc = of_property_read_u32(child,
				"qcom,hw-settle-time", &hw_settle_time);
			if (rc) {
				pr_err("Invalid channel hw settle time property\n");
				return -EINVAL;
			}
			rc = of_property_read_u32(child,
				"qcom,pre-div-channel-scaling", &scaling);
			if (rc) {
				pr_err("Invalid channel scaling property\n");
				return -EINVAL;
			}
			rc = of_property_read_u32(child,
				"qcom,scale-function", &post_scaling);
			if (rc) {
				pr_err("Invalid channel post scaling property\n");
				return -EINVAL;
			}
			rc = of_property_read_string(child,
				"qcom,calibration-type", &calibration_param);
			if (rc) {
				pr_err("Invalid calibration type\n");
				return -EINVAL;
			}
			if (!strcmp(calibration_param, "absolute"))
				calib_type = CALIB_ABSOLUTE;
			else if (!strcmp(calibration_param, "ratiometric"))
				calib_type = CALIB_RATIOMETRIC;
			else {
				pr_err("%s: Invalid calibration property\n",
						__func__);
				return -EINVAL;
			}
		}
		rc = of_property_read_u32(child,
				"qcom,fast-avg-setup", &fast_avg_setup);
		if (rc) {
			pr_err("Invalid channel fast average setup\n");
			return -EINVAL;
		}
		/* Individual channel properties */
		adc_channel_list[i].name = (char *)channel_name;
		adc_channel_list[i].channel_num = channel_num;
		adc_channel_list[i].adc_decimation = decimation;
		adc_channel_list[i].fast_avg_setup = fast_avg_setup;
		if (!of_device_is_compatible(node, "qcom,qpnp-iadc")) {
			adc_channel_list[i].chan_path_prescaling = scaling;
			adc_channel_list[i].adc_scale_fn = post_scaling;
			adc_channel_list[i].hw_settle_time = hw_settle_time;
			adc_channel_list[i].calib_type = calib_type;
		}
		i++;
	}

	/* Get the ADC VDD reference voltage and ADC bit resolution */
	rc = of_property_read_u32(node, "qcom,adc-vdd-reference",
			&adc_prop->adc_vdd_reference);
	if (rc) {
		pr_err("Invalid adc vdd reference property\n");
		return -EINVAL;
	}
	rc = of_property_read_u32(node, "qcom,adc-bit-resolution",
			&adc_prop->bitresolution);
	if (rc) {
		pr_err("Invalid adc bit resolution property\n");
		return -EINVAL;
	}
	adc_qpnp->adc_prop = adc_prop;

	/* Get the peripheral address */
	res = spmi_get_resource(spmi, 0, IORESOURCE_MEM, 0);
	if (!res) {
		pr_err("No base address definition\n");
		return -EINVAL;
	}

	adc_qpnp->slave = spmi->sid;
	adc_qpnp->offset = res->start;

	/* Register the ADC peripheral interrupt */
	adc_qpnp->adc_irq_eoc = spmi_get_irq_byname(spmi, NULL,
						"eoc-int-en-set");
	if (adc_qpnp->adc_irq_eoc < 0) {
		pr_err("Invalid irq\n");
		return -ENXIO;
	}

	init_completion(&adc_qpnp->adc_rslt_completion);

	return 0;
}
EXPORT_SYMBOL(qpnp_adc_get_devicetree_data);
